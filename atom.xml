<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Abbey in Cradle Studio]]></title>
  <subtitle><![CDATA[年少轻狂 | 立志成为一名游戏开发极客]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.abbeychenxi.net/"/>
  <updated>2014-11-18T14:50:22.802Z</updated>
  <id>http://www.abbeychenxi.net/</id>
  
  <author>
    <name><![CDATA[Abbey]]></name>
    <email><![CDATA[Abbeychenx@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[分布式系统]]></title>
    <link href="http://www.abbeychenxi.net/2014/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.abbeychenxi.net/2014/11/18/分布式系统/</id>
    <published>2014-11-18T14:43:01.000Z</published>
    <updated>2014-11-18T14:43:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="中间件在分布式系统中的地位和角色">中间件在分布式系统中的地位和角色</h2>
<p>为了使种类各异的计算机和网络都呈现为单个的系统，分布式系统常常通过一个“软件层”组织起来，该层在逻辑上位于由用户和应用程序组成的高层与由操作系统组成的低层之间，这样的分布式系统又称为中间件。中间件层延伸到了多台机器上，且为每个应用程序提供了相同的接口。它的重要的目的是提供一定程度的透明性，也就是一定程度上向应用程序隐藏数据处理的分布性。中间件集分布式操作系统与网络操作系统的优点于一身，既能够具有网络操作系统的可扩展性和开放性，又能够具有分布式操作系统的透明性和与之相关的易用性。</p>
<h2 id="分布式系统进程通信，rpc基本原理步骤">分布式系统进程通信，rpc基本原理步骤</h2>
<ol>
<li>客户过程以正常方式调用客户存根</li>
<li>客户存根生成一个消息，然后调用本地操作系统</li>
<li>客户端操作系统将消息发送给远程操作系统，并阻塞客户过程</li>
<li>远程操作系统将消息交给服务器存根</li>
<li>服务器存根将参数提取出来，然后调用服务器</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根</li>
<li>服务器存根将结果打成消息包，然后调用本地操作系统</li>
<li>服务器操作系统将消息发送回客户端操作系统</li>
<li>客户端操作系统将消息交给客户存根</li>
<li>客户存根将结果从消息中提取出来，返回给调用进程</li>
</ol>
<h2 id="移动agent特点">移动agent特点</h2>
<p>自主性；反应性；主动/面向目标；推理/学习/自适应能力；可移动性；社会性。</p>
<h2 id="命名服务(优缺点)">命名服务(优缺点)</h2>
<h2 id="移动实体定位">移动实体定位</h2>
<ol>
<li>广播和多播</li>
<li>转发指针</li>
<li>给实体指定一个起始位置</li>
<li>创建一颗搜索树</li>
</ol>
<h2 id="并发，petri网建模">并发，petri网建模</h2>
<h3 id="哲学家进餐">哲学家进餐</h3>
<p><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfhdhmzsgj218e0v4jv8.jpg" alt="哲学家进餐"></p>
<p>图解：</p>
<p>h-hunger   k-thinking   f –fork/chopstick   e-eating</p>
<ol>
<li>圆圈：hi,ki,ei,fi为库所<br>h：表示为哲学家饥饿状态库所 : k表示为哲学家思考状态的库所 e:表示为哲学家吃饭状态的库所 f:表示筷子处于备用状态的库所</li>
<li>黑色实心点为token。初始状态时：f0-f4中的是筷子，k0-k4中的是哲学家</li>
<li>方框为变迁<br>初始状态：筷子备用状态，处于f0-f4库所中。哲学家是思考状态，处于k0-k4中。</li>
</ol>
<p>以哲学家0为例</p>
<ul>
<li>T1 变迁1（感到饥饿）：哲学家在思考中感到饿了，从库所k0经过T1到达库所h0。哲学家从思考状态进入饥饿状态。</li>
<li>T2变迁2（获得筷子）：哲学家和筷子分别从h0，f4，f0库所经过T2迁移到库所e0。哲学家从饥饿状态进入吃饭状态。</li>
<li>T3变迁3（释放筷子）：吃完饭后，哲学家经过T3迁移到k0库所中，从吃饭状态转入思考状态。两只筷子经过T3，分别迁移到库所f0，f4，从使用状态进入备用状态。</li>
</ul>
<h3 id="生产者消费者">生产者消费者</h3>
<p><img src="http://ww4.sinaimg.cn/mw690/b34f7e8bgw1emfhj3gp7wj21fm0ladjn.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/mw690/b34f7e8bgw1emfhjevzcrj20te0isdhh.jpg" alt=""></p>
<h2 id="移动mogent通信失效（本地和异地）的解决方案">移动mogent通信失效（本地和异地）的解决方案</h2>
<ul>
<li>分析<ul>
<li>无论本地通信还是异地通信，其通信模型是一致的 </li>
<li>通信失效本质上都是因为在路由信件和实际信件传输过程中，目标agent发生了物理位置的变化，而这种变化是随机的，不可预计的。 </li>
</ul>
</li>
<li>结论<ul>
<li>通信失效现象并不是mogent系统特有的现象.它是一个因agent的移动而带来的可能会出现在任意一个移动agent系统中的普遍现象</li>
</ul>
</li>
<li>其它系统的处理<ul>
<li>Aglets：未见</li>
<li>Mole：<ul>
<li>将失效信件扔弃;</li>
<li>扔弃的同时回送错误信息</li>
<li>将失效信件就地保存,待被通信agent在回送时交付 </li>
</ul>
</li>
</ul>
</li>
<li>根本原因：<ul>
<li>移动：随机改变位置信息</li>
<li>通信：要求位置信息“暂时”不变</li>
<li>通信和移动所共享的“位置”信息未进行同步控制是造成通信失效的根本原因</li>
<li>从OS进程互斥考虑，接收者的“位置”在通信失效问题中具有决定性的意义，当通信和移动相矛盾时，该“位置”就成为了一个必须互斥使用的“资源” </li>
</ul>
</li>
<li>“位置”的互斥  ＝》  “状态”的互斥</li>
<li>在一个能够避免通信失效的移动agent系统中，必须且只要做到以下三条 ：<ul>
<li>准确纪录agent的状态信息 </li>
<li>只能向一个处于“静止态”的agent发送信件 </li>
<li>信件发送过程中必须限制接收者从“静止态”向“移动态”的状态转换 </li>
</ul>
</li>
</ul>
<h2 id="同步：逻辑时间算法，向量时间戳（将每个时间的向量时间戳标出）">同步：逻辑时间算法，向量时间戳（将每个时间的向量时间戳标出）</h2>
<p>Lamport算法：不能反应因果关系。</p>
<p>向量时钟 ：要求能计算出每个进程中的事件，标出向量的时间戳，不同事件之间的向量时间的大小关系，依赖关系与并发关系。</p>
<h3 id="逻辑时钟">逻辑时钟</h3>
<ul>
<li>为了同步逻辑时钟，Lamport定义了一个称作 “先发生” (happens-before) 的关系。表达式ab读作 “a在b之前发生”，意思是所有进程一致认为事件a先发生，然后事件b才发生。这种先发生关系有两种情况。 <ul>
<li>如果a和b是同一个进程中的两个事件，且a在之前发生，则ab为真。 </li>
<li>如果a是一个进程发送消息的事件，而b为另一个进程接收消息的事件，则ab也为真。消息不可能在发送之前被修改，也不能在发送的同时被接收，这是因为消息需要一定时间才能到达接收端。 </li>
<li>Lamport逻辑时间钟具有传递性和并发性；</li>
</ul>
</li>
<li>对这个算法稍作补充就可以满足全局时间的需要。即在每两个事件之间，时钟必须至少滴答一次。如果一个进程以相当快的速度发送或者接受两个消息，那么它的时钟必须在这之间至少滴答一次。 </li>
<li>在某些情况下还需要一个附加条件，即两个事件不会精确地同时发生。为了达到这个目标，我们可以将事件发生所在的进程号附加在时间的低位后，并用小数点分开。这样，如果进程1和进程2中的事件都发生在时刻40，那么前者记为40.1后者记为40.2。 </li>
<li>使用这种方法，我们现在有了一个为分布式系统中的所有事件分配时间的方法，它遵循下面的规则： <ul>
<li>若同一进程中a在b之前发生，则C(a)&lt;C(b)。 </li>
<li>若a和b分别代表发送一个消息和接收该消息的事件，则C(a)&lt;C(b)。 </li>
<li>对于所有不同的事件a和b，C(a) ≠ C(b)。</li>
</ul>
</li>
<li>这个算法为我们提供了一种对系统中所有事件进行完全排序的方法。许多其他的分布式算法都需要这种排序以避免混淆，所以文献中广泛引用此算法。 </li>
<li>使用Lamport时间戳后，只通过比较事件a和b各自的时间值C(a)和C(b)，无法说明它们之间的关系。换句话所，C(a)&lt;C(b)不能说明事件a就是在事件b之前发生。还需要另外一些信息。即 Lamport时间戳不能捕捉因果关系(causality)。</li>
</ul>
<h3 id="向量事件戳">向量事件戳</h3>
<p>为什么采用向量时间戳可以表示事件因果关系？</p>
<ul>
<li>因果关系可以通过向量时间戳来捕获。分配给事件a的向量时间戳VT(a)具有下列性质：如果对某一事件b，有VT(a)&lt;VT(b)，那么认为事件a在因果关系上处于事件b之前。向量时间戳的创建是通过让每个进程P维护一个向量V来完成的，该向量具有下面两个性质： <ul>
<li>Vi[i]是到目前为止进程Pi发生的事件的数量。 </li>
<li>如果Vi[j]=k，那么进程Pi知道进程Pj中已经发生了k个事件</li>
<li>第一个性质是通过在进程Pi中的新事件发生时递增Vi[i]来维护的。</li>
<li>第二个性质时通过在所发送的消息中携带向量来维护的。当进程Pi发送消息m时，它将自己的当前向量作为时间戳vt一起发送。 </li>
</ul>
</li>
<li>使用这种方式，接收者可以得知进程Pi中已经发生的事件数。</li>
<li>更重要的是，接收者可以得知进程Pi发送消息m之前其他进程已经发生了多少个事件。换句话说，消息m的时间戳vt告诉接收者其他进程中有多少事件发生在它之前，并且消息m可能在因果关系上依赖于这些事件。</li>
<li><p>当进程Pj接收到消息m时，它调整自己的向量，将每项Vj[k] 设置为max{Vj[k],vt[k]}。该向量现在反映了进程Pj必须接收的消息数，该消息数目至少是在发送消息m之前见到的消息。此后将Vj[i]项增1，这表示接收消息m的事件是来自于进程Pi的下一个事件。<br>只在不违背因果关系限制时，才能使用向量时间戳来传递消息。我们来再次考虑一下电子公告板的例子。当进程Pi张贴一篇文章时，它将该文章作为消息a广播出去，并且在该消息上附加一个时间戳vt(a)，其值等于V。当另一个进程Pj接收到a时，它将调整自己的向量，以使Vj[i]=vt(a)[i]。</p>
</li>
<li><p>现在假设进程Pj张贴了一个该文章的回复。回复是通过该进程广播一个消息r实现的，消息r携带值等于Vj的时间戳vt(r)。注意vt(r)[i]&gt; vt(a)[i]。假设通信是可靠的，包含文章的消息a和包含回复的消息r最终都到达了另一个进程Pk。因为我们没有对消息的顺序关系做出假设，所以消息r可能在消息a之前到达进程Pk。进程Pk接收到消息r时检查时间戳，并决定推迟提交消息r，直到因果关系上位于r之前的消息都接收到了才提交。消息r只有下列条件满足时才得到交付：<br>vt(r)[j]=vk[j]+1;<br>对于所有满足i¹j的i和j，vt(r)[i]&lt; Vk[i]<br>第一个条件说明r是进程Pk正在等待的下一条来自进程Pj的消息。<br>第二个条件说明当进程Pj发送消息r时，进程Pk只看到被进程Pj看到的消息。这意味着进程Pk已经看到了消息。</p>
</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfikdx9x2j20sq0wi0vu.jpg" alt=""></p>
<h2 id="一致性模型，要能写出以客户为中心的四个模型（条件描述）以数据为中心的三种类别（了解））">一致性模型，要能写出以客户为中心的四个模型（条件描述）以数据为中心的三种类别（了解））</h2>
<ol>
<li><p>每一个以客户为中心的一致性模型是单调读的一致性模型。如果数据存储满足以下条件，那么称该数据存储提供单调读一致性(monotonic-read consistency)： </p>
<ul>
<li><p>如果一个进程读取数据x的值，那么该进程对执行任何后续读操作将总是得到第一次读取的那个值或更新的值。 </p>
<p>也就是说，单调读一致性保证，如果一个进程已经在t时刻看到x的值，那么以后他不再会看到较老的版本的x的值。 </p>
</li>
</ul>
</li>
<li><p>在很多情况下，写操作以正确的顺序传播到数据存储的所有拷贝是非常重要的。这种性质被描述为单调写一致性。单调写一致性(monotonic-write consistency)的数据存储应该满足以下条件： </p>
<ul>
<li>一个进程对数据项x执行的写操作必须在该进程对x执行任何后续写操作之前完成。 </li>
</ul>
</li>
<li><p>下面介绍一种与单调写一致性有密切关系的以客户为中心的一致性模型。如果数据存储满足以下条件，那么称该数据存储提供写后读一致性(read-your-writes consistency)。 </p>
<ul>
<li><p>一个进程对数据项x执行一次写操作的结果总是会被该进程对x执行的后续读操作看见。 </p>
<p>也就是说，一个写操作总是在同一进程执行的后续读操作之前完成，而不管这个后续的读操作发生在什么位置。</p>
</li>
</ul>
</li>
<li><p>最后一种以客户为中心的一致性模型是这样的模型，即更新是作为前一个读操作的结果传播的。如果数据存储满足以下条件，那么称该数据存储提供读后写一致性(writes-follow-reads consistency)。 </p>
<ul>
<li><p>同一个进程对数据项x执行的读操作之后的写操作，保证发生在与x读取值相同或比之更新的值上。</p>
<p>也就是说，进程对数据项上x所执行的任何后续的写操作都会在x的拷贝上执行，而该拷贝是用该进程最近读取的值更新的。</p>
</li>
</ul>
</li>
</ol>
<h2 id="代码迁移（基础、分类）">代码迁移（基础、分类）</h2>
<p>分布式系统中的代码迁移是以进程迁移(process migration)的形式进行的，在这种形式下整个进程被从一台机器搬到另一台机器上去。其基本的思想是：如果把进程由负载较重的机器上转移到负载较轻的机器上去，就可以提升系统的整体性能。（迁移的是计算程序本身，而非数据）</p>
<h3 id="分类">分类</h3>
<ul>
<li>弱可迁移性：在这种模型中，可以只传输代码段以及某些初始化数据。弱可移动性的典型特征是，传输过来的程序总是以初始状态重新开始执行的。</li>
<li>强可移动性(strong mobility)：它还可以迁移执行段。强可移动性的典型特征是，可以先停止运行中的进程，然后将它搬到另一台机器上去，再从刚才中断的位置继续执行。 </li>
</ul>
<p>分类（主动方）：</p>
<ul>
<li>发送者启动(sender-initiated)迁移：在这种模型中，代码当前驻留在哪台机器上或者正在哪台机器上执行，就由该机器来启动迁移。一般来说，在向计算服务器上载程序时进行的就是发送者启动的迁移。</li>
<li>接收者启动(receiver-initiated)迁移：代码迁移的主动权掌握在目标机器手中。Java小程序是这种迁移的一个例子。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfinpb34nj21au0p2dj7.jpg" alt=""></p>
<h2 id="事务提交：2pc\3pc">事务提交：2pc\3pc</h2>
<ol>
<li><p>两阶段提交协议(2PC)：考虑一个分布式事务中有很多进程作为参与者，每个进程都运行在不同的机器上。假定没有故障发生，协议就由以下两个阶段组成，每个阶段又由两步组成。</p>
<ul>
<li>协调者向所有的参与者发送一个Vote_Request消息。 </li>
<li>当参与者接收到Vote_Request消息时，就向协调者返回一个Vote_Commit消息通知协调者它已经准备好本地提交事务中属于它的部分，否则就返回一个Vote_Abort消息。 </li>
<li>协调者收集来自参与者的所有选票。如果所有的参与者都表决要提交事务，那么协调者就进行提交。在这种情况下它向所有的参与者发送一个Global_Commit消息。但是，如果有一个参与者表决要取消事务，那么协调者就决定取消事务并多播一个Global_Abort消息。 </li>
<li><p>每个提交表决的参与者都等待协调者的最后反应。如果参与者接收到一个Global_Commit消息，那么它就在本地提交事务，否则接收到一个Global_Abort消息时，就在本地取消事务。<br><img src="http://ww4.sinaimg.cn/mw690/b34f7e8bjw1emfibctv28j21bi0cudi7.jpg" alt=""></p>
<ul>
<li>The finite state machine for the coordinator in 2PC.（协调者）</li>
<li>The finite state machine for a participant.（参与者）</li>
</ul>
<p>两阶段提交的一个问题在于当协调者崩溃时，参与者不能做出最后的决定。因此参与者可能在协调者恢复之前保持阻塞。三阶段提交协议(3PC)，避免了在出现故障停机时的阻塞过程。</p>
</li>
</ul>
</li>
<li><p>三阶段提交（3PC）</p>
<p> 3PC的本质在于协调者和每个参与者都满足以下两个条件： </p>
<ul>
<li>没有一个可以直接转换到Commit或者Abort状态的单独状态。 </li>
<li><p>没有一个这样的状态：它不能做出最后决定，而且可以从它直接转换到Commit状态。  </p>
<p>三阶段提交协议(3PC)的基本原理为：在2PC的参与者投票和协调者决策之间增加了“预提交”阶段。协调者在接收到所有参与者的提交票后发送一个全局预提交命令，当参与者接收到全局预提交命令之后，它就得知其他的参与者都投了提交票，从而确定自己在稍后肯定会执行提交操作，除非它失败了。每个参与者都对全局预提交发出确认消息，协调者一旦接收到所有参与者的确认消息就再发出“全局性提交”。3PC协议在站点失败，甚至是所有的站点都失败的情况下也不会带来阻塞。</p>
<p>它们各自的状态机如图所示。（a 协调者，b 参与者）<br><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfidmwjbnj21d40hwwhr.jpg" alt=""></p>
</li>
</ul>
</li>
</ol>
<ul>
<li>二者比较：</li>
</ul>
<p>与2PC相比，3PC的主要不同点在于以下情况：崩溃的参与者可能恢复到了Commit状态而所有参与者还处于Ready状态。在这种情况下，其余的可能操作进程不能做出最后的决定，不得不在崩溃的进程恢复之前阻塞。在3PC中，只要有可操作的进程处于Ready状态，就没有崩溃的进程可以恢复到Init、Abort或Precommit之外的状态。因此存活进程总是可以做出的最后决定。 </p>
<h2 id="复制和一致性（四个经典模型（不带同步变量的））">复制和一致性（四个经典模型（不带同步变量的））</h2>
<ol>
<li><p>严格一致性</p>
<p> 条件定义：对于数据项x的任何读操作将返回最近一次对x进行的写操作的结果所对应的值。 </p>
<p> 严格一致性中存在的问题是它依赖于绝对的全局时间(注意由于技术的限制,我们需要处理同一时间间隔内所发生的多个操作)</p>
<p> <img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfhxjvyg6j21d409qwex.jpg" alt=""><br> (a)严格的一致性存储; (b) 非严格的一致性存储 </p>
<p> 总之，当数据存储是严格一致的时候，对于所有的进程来说，所有写<br> 操作是瞬间可见的，系统维持着一个绝对的全局时间顺序。(如果一<br> 个数据项被改变了，那么无论数据项改变之后多久执行读操作，无论<br> 哪些进程执行读操作，无论这些进程的位置如何，所有在该数据项上<br> 执行的后续读操作都将得到新数值。同样，如果执行了读操作，那么<br> 无论多快地执行下一个写操作，该读操作都将得到当前的值。 )</p>
</li>
</ol>
<ol>
<li><p>顺序一致性</p>
<p> 条件定义: </p>
<p> 任何执行结果都是相同的，就好像所有进程对数据存储的读、写操作    时按照某种序列顺序执行的，并且每个进程的操作按照程序所制定的    顺序出现在这个序列中。 </p>
<p> <img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfi1uz27qj21aa09iab4.jpg" alt=""><br> (a) 顺序一致的数据存储； (b)非顺序一致的数据存储 </p>
</li>
<li><p>线性一致性</p>
<p> 条件定义：当数据存储上的每个操作都具有时间戳并满足以下条件时，称这个数据存储是可线性化的。任何执行结果都是相同的，就好像所有进程对数据存储的读、写操作是按某种顺序执行的，并且每个进程的操作按照顺序所执行的顺序出现在这个顺序中。另外，如果tsop1(x)&lt;tsop2(y)，那么在这个顺序中，操作OP1(x)出现在操作OP2之前。 （注意，可线性化的数据存储也是顺序一致的。它们的区别在于：线性化是根据一系列同步时钟确定序列顺序的。在实际应用中，线性化主要用于开发算法的形式验证。关于根据时间戳维护顺序的附加限制使得线性化的实现比顺序一致性的实现开销更大。Tsop(x)—-时间戳）。</p>
</li>
<li><p>因果一致性</p>
<p> 因果关系理解：考虑一个存储器的实例。假设进程P1对变量x执行了写操作。然后进程P2先读取x，然后对y执行写操作。这里，对x的读操作和对y的写操作具有潜在的因果关系，因为y的计算可能依赖于P2所读取的x值。没有因果关系的操作被称为并发的。</p>
<p> 条件定义：所有进程必须以相同的顺序看到具有潜在因果关系的写操作。不同机器上的进程可以以不同的顺序被看到并发的写操作。<br>实现因果一致性要求跟踪哪些进程看到了哪些写操作。这意味着必须构建和维护一张记录哪些操作依赖于哪些操作的依赖关系图。一种实现方法是使用上一章所讨论的向量时间戳。</p>
</li>
</ol>
<h2 id="分布式系统算法（选举算法（欺负算法）、互斥算法（集中式带协调者的、分布式不带协调者的、recut、令牌环（不一定考）））">分布式系统算法（选举算法（欺负算法）、互斥算法（集中式带协调者的、分布式不带协调者的、recut、令牌环（不一定考）））</h2>
<h2 id="选举算法">选举算法</h2>
<h3 id="欺负算法">欺负算法</h3>
<p>1.1 当任何一个进程发现协调者不再响应请求时，它就发起一个选举。进程P按如下过程主持一次选举： </p>
<ul>
<li>1.1.1 P向所有编号比它大的进程发送一个election消息； </li>
<li>1.1.2 如果无人响应，P获胜成为协调者； </li>
<li>1.1.3 如果有编号比它大的进程响应，则响应者接管选举工作。P的工作完成。</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/mw690/b34f7e8bgw1emfhom07xqj21ci0fqwgr.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfhomlpx8j21ba0fgdhe.jpg" alt=""></p>
<ul>
<li>(a)  进程4主持一个选举；</li>
<li>(b) 进程5和6进行响应，告诉进程4停止选举；</li>
<li>(c) 进程5和6此时各自主持一个选举；</li>
<li>(d) 进程6通知进程5停止选举；</li>
<li>(e) 进程6获胜，并通知每个进程。</li>
</ul>
<h2 id="互斥算法">互斥算法</h2>
<h3 id="集中式算法">集中式算法</h3>
<p>只有一个协调者，无论何时一个进程要进入临界区，它都要向协调者发送一个请求消息，说明它想要进入哪个临界区并请求允许。如果当前没有其他进程在该临界区内，协调者就发送允许进入的应答消息。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfht04vfvj21900e0q4l.jpg" alt=""></p>
<ul>
<li>(a) 进程1请求协调者允许它进入一个临界区。请求得到了批准； </li>
<li>(b) 进程2也请求进入同一个临界区。协调者不应答；进程2进入等待队列</li>
<li>(c) 进程1在退出临界区时通知协调者，协调者然后做出应答。协调者再通知等待队列中的排在最前面的进程2进入临界区</li>
<li>优点：没有进程会处于永远等待状态(不会出现饿死的情况)；易于实现，每使用一次临界区只需3条消息(请求、允许和释放)；不仅能用于管理临界区，也可以用于更一般的资源分配。 </li>
<li>缺点：协调者是一个单个故障点，所以如果它崩溃了，整个系统就可能瘫痪。在一般情况下，如果进程在发出请求之后被阻塞，那么请求者就不能区分“拒绝进入”和协调者已经崩溃这两种情况，因为上述两种情况都没有消息返回。此外，在规模较大的系统中，单个协调者会成为性能的瓶颈。</li>
</ul>
<h3 id="分布式算法">分布式算法</h3>
<p>该算法的工作过程如下：当一个进程想进入一个临界区时，它构造一个消息，其中包含它要进入的临界区的名字、它的进程号和当前时间。然后它将消息发送给所有其他的进程，理论上讲也包括它自己。<br>当一个进程接收到来自另一个进程的请求消息时，它根据自己与消息中的临界区相关的状态来决定它要采取的动作。可以分为三种情况： </p>
<ul>
<li>2.1 若接收者不再临界区也不想进入临界区，它就向发送者发送一个OK消息。 </li>
<li>2.2 若接收者已经在临界区，它不进行应答，而是将该请求放入队列中。 </li>
<li>2.3 如果接收者想进入临界区但尚未进入时，它将对收到的消息的时间戳和包含在它发送给其余进程的消息中的时间戳进行比较。时间戳最早的那个进程获胜。如果收到的消息的时间戳比较早，那么接收者向发送者发回一个OK消息。如果它自己的消息的时间戳比较早，那么接收者将接收到的请求放入队列中，并且不发送任何消息。</li>
</ul>
<p>在发送了请求进入临界区的请求消息后，进程进行等待，直到其他所有进程都发回允许进入消息为止。一旦得到所有进程的允许，它就可以进入临界区了。当它退出临界区时，它向其他队列中的所有进程发送OK消息，并将它们从队列中删除。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/b34f7e8bgw1emfhuu9pp4j21bm0f8q4d.jpg" alt=""></p>
<ul>
<li>(a) 两个进程同时希望进入同一个临界区； </li>
<li>(b) 进程0具有最早的时间戳，所以它获胜； </li>
<li>(c) 当进程0退出临界区时，它发送一个OK消息，所以进程2现在可以进入临界区 <ul>
<li>优点：不会发生死锁或者饿死现象；最大的优点是不存在单个故障点。</li>
<li>缺点：单个故障点被n个故障点所取代；要求更多网络通信的算法；要么必须使用组通信原语，要么每个进程都必须自己维护组成员的清单，清单中包括进入组的进程、离开组的进程以及崩溃的进程。</li>
</ul>
</li>
</ul>
<h3 id="令牌环">令牌环</h3>
<p>当环初始化时，进程0得到一个令牌token。该令牌绕着环运行，用点对点发送消息的方式把它从进程k传递到进程k+1(以环大小为模)。进程从它邻近的进程得到令牌后，检查自己是否要进入临界区。如果自己要进入临界区，那么它就进入临界区，做它要做的工作，然后离开临界区。在该进程退出临界区后，它沿着环继续传递令牌。不允许使用同一个令牌进入另一个临界区。如果一个进程得到了邻近进程传来的令牌，但是它并不想进入临界区，那么它只是将令牌沿环往下传递。</p>
<ul>
<li>优点：不会发生饿死现象，那么最差的情况是等待其他所有进程都进入这个临界区然后再从中退出后它再进去。</li>
<li>缺点：如果令牌丢失了，那么它必须重新生成令牌，检测令牌丢失是很困难的；如果有进程崩溃，该算法也会出现麻烦，但是恢复起来比其他算法容易。</li>
</ul>
]]></content>
    
    
      <category term="分布式" scheme="http://www.abbeychenxi.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="NJUStudying" scheme="http://www.abbeychenxi.net/categories/NJUStudying/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关联规则]]></title>
    <link href="http://www.abbeychenxi.net/2014/11/12/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/"/>
    <id>http://www.abbeychenxi.net/2014/11/12/关联规则/</id>
    <published>2014-11-12T01:48:27.000Z</published>
    <updated>2014-11-12T01:49:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="关联规则">关联规则</h2>
<h1 id="关联规则挖掘">关联规则挖掘</h1>
<p>$ support(A =&gt; B) = P(A U B) $<br>$ confidence(A =&gt; B) = P(AUB)/P(A) $</p>
<ol>
<li>找出频繁项集</li>
<li>由频繁项集产生强关联规则</li>
</ol>
<h1 id="由事务数据库挖掘单维布尔关联规则">由事务数据库挖掘单维布尔关联规则</h1>
<h2 id="Apriori算法:_使用候选项集找频繁项集">Apriori算法: 使用候选项集找频繁项集</h2>
<ol>
<li>连接</li>
<li>剪枝</li>
</ol>
<h2 id="由频繁项集产生关联规则">由频繁项集产生关联规则</h2>
<p>$ confidence(A =&gt; B) = P(A|B) = supportcount(A U B)\div supportcount(A) $</p>
<h2 id="提高Apriori有效性">提高Apriori有效性</h2>
<ol>
<li>基于散列的技术</li>
<li>事务压缩</li>
<li>划分</li>
<li>选样</li>
<li>动态项集计数</li>
</ol>
<p><em>FP-树</em></p>
<h3 id="冰山查询">冰山查询</h3>
<h1 id="多层关联规则">多层关联规则</h1>
<h2 id="挖掘量化关联规则">挖掘量化关联规则</h2>
<ul>
<li>分箱: 等宽分箱 等深分箱 基于同质分箱</li>
<li>找频繁谓词集</li>
<li>关联规则聚类</li>
</ul>
<p>A和B相关性: $ P(A U B)\div (P(A) * P(B)) $</p>
]]></content>
    
    
      <category term="data mining" scheme="http://www.abbeychenxi.net/tags/data-mining/"/>
    
      <category term="NJUStudying" scheme="http://www.abbeychenxi.net/categories/NJUStudying/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[bcy抓站小结]]></title>
    <link href="http://www.abbeychenxi.net/2014/10/31/bcy%E6%8A%93%E7%AB%99%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.abbeychenxi.net/2014/10/31/bcy抓站小结/</id>
    <published>2014-10-31T10:30:22.000Z</published>
    <updated>2014-10-31T10:38:39.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>目标: 抓取bcy.net/party/all所有的漫展信息</li>
<li>分析发现 bcy.net 通过js，ajax请求 获取下周等标签下的漫展信息</li>
</ol>
<h2 id="解决方案">解决方案</h2>
<ol>
<li>尝试通过Scrapyjs来模拟js交互。但是没有弄得middleware等等问题</li>
<li>尝试使用webdriver；但是速度太慢，严重影响效率</li>
<li>研究bcy的network标签，发现下周等标签会有一个ajax的post请求</li>
</ol>
<h2 id="最终解决方法">最终解决方法</h2>
<ul>
<li>研究ajax的post请求，发现网页指向<a href="http://bcy.net/party/expo/almexpoindex" target="_blank" rel="external">http://bcy.net/party/expo/almexpoindex</a></li>
<li>打开 <a href="http://bcy.net/party/expo/almexpoindex" target="_blank" rel="external">http://bcy.net/party/expo/almexpoindex</a> 查看network标签，发现有一个get请求</li>
<li>回到之前页面，找到ajax请求下面的formdata数据，利用formdata数据构建新的url，模拟post请求</li>
<li>查看network标签，成功收到返回的网页漫展信息的数据</li>
</ul>
<h1 id="大功告成！">大功告成！</h1>
]]></content>
    
    
      <category term="Scrapy" scheme="http://www.abbeychenxi.net/tags/Scrapy/"/>
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="cosjy" scheme="http://www.abbeychenxi.net/categories/cosjy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[manzhan.com的爬虫抓站小结]]></title>
    <link href="http://www.abbeychenxi.net/2014/10/23/manzhan-com%E7%9A%84%E7%88%AC%E8%99%AB%E6%8A%93%E7%AB%99%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.abbeychenxi.net/2014/10/23/manzhan-com的爬虫抓站小结/</id>
    <published>2014-10-22T17:13:55.000Z</published>
    <updated>2014-10-25T19:05:35.000Z</updated>
    <content type="html"><![CDATA[<p>目标网站: www.manzhan.com<br>使用框架: Scrapy</p>
<h1 id="新建项目">新建项目</h1>
<p><code>scrapy startproject manzhan</code></p>
<p>各文件的作用:</p>
<ul>
<li>scrapy.cfg: 项目的配置文件</li>
<li>manzhan/: 项目的Python模块</li>
<li>manzhan/items.py: 项目的items文件</li>
<li>manzhan/pipelines.py: 项目的pipelines文件</li>
<li>manzhan/settings.py: 项目的设置文件</li>
<li>manzhan/spiders/: 存储爬虫的目录</li>
</ul>
<h1 id="明确目标">明确目标</h1>
<p>在Scrapy中，items是用来加载抓取内容的容器。<br>需要抓取的内容：</p>
<ul>
<li>title</li>
<li>date</li>
<li>location</li>
<li>site</li>
<li>theme</li>
<li>type</li>
<li>link</li>
</ul>
<p>创建item类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="title">from</span> scrapy.item <span class="import"><span class="keyword">import</span> Item, Field</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> manzhanItem<span class="container">(<span class="type">Item</span>)</span>:</div><div class="line">	title = <span class="type">Field</span><span class="container">()</span></div><div class="line">	date = <span class="type">Field</span><span class="container">()</span></div><div class="line">	location = <span class="type">Field</span><span class="container">()</span></div><div class="line">	site = <span class="type">Field</span><span class="container">()</span></div><div class="line">	theme = <span class="type">Field</span><span class="container">()</span></div><div class="line">	type = <span class="type">Field</span><span class="container">()</span></div><div class="line">	link = <span class="type">Field</span><span class="container">()</span></div></pre></td></tr></table></figure>

<h1 id="制作爬虫">制作爬虫</h1>
<p>制作爬虫分为两步: 先爬再取</p>
<h2 id="爬">爬</h2>
<p>Spider是用户自己编写的类，用来从一个域内抓取信息。<br>他们定义了用于下载的URL列表、跟踪链接的方案、解析网页内容的方式，以此来提取items。<br>要建立一个Spider，你必须用scrapy.spider.BaseSpider创建一个子类，并确定三个强制的属性:</p>
<ul>
<li>name: 爬虫的识别名称，必须唯一</li>
<li>start_urls: 爬虫的URL列表。爬虫从这里开始抓取数据。第一次的数据会从这些urls开始。其他子URL将会从这些起始URL中继承性生成</li>
<li>parse(): 解析方法，调用的时候传入从每一个URL传回的Response对象作为唯一参数，负责解析并匹配抓取的数据，跟踪更多的URL。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scrapy.spider <span class="keyword">import</span> Spider</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManzhanSpider</span><span class="params">(Spider)</span>:</span></div><div class="line">	name = <span class="string">"manzhan"</span></div><div class="line">	allowed_domains = [<span class="string">"manzhan.com"</span>]</div><div class="line">	start_urls = [</div><div class="line">		<span class="string">"http://www.manzhan.com"</span></div><div class="line">	]</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">		filename = response.url</div><div class="line">		open(filename, <span class="string">'wb'</span>).write(response.body)</div></pre></td></tr></table></figure>

<p>allow_domains是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页。<br>测试 scrapy crawl manzhan</p>
<h2 id="取">取</h2>
<p>在基础的爬虫里，这一步可以用正则式来抓。<br>在Scrapy里，使用一种叫做Xpath selectors的机制，它基于Xpath表达式。<br>在Scrapy里面， Selectors有四种基础的方法:</p>
<ul>
<li>xpath(): 返回一系列的selectors，每一个select表示一个xpath参数表达式选择的节点</li>
<li>css(): 返回一系列的selectors，每一个select表示一个css参数表达式选择的节点</li>
<li>extract(): 返回一个unicode字符串，为选中的数据</li>
<li>re(): 返回一串一个unicode字符串，为使用正则表达式抓取出来的内容</li>
</ul>
<p>具体的xpath表达式</p>
<ul>
<li>nodename  选取此节点的所有子节点</li>
<li>/   从根节点选取</li>
<li>//  从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</li>
<li>.   选取当前节点</li>
<li>..  选取当前节点的父节点</li>
<li>@   选取属性</li>
<li>count 当前节点包含其他节点</li>
<li>[1] 当前节点在文件中的位置</li>
</ul>
<p>parse函数更改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">	sel = Selector(response)</div><div class="line">	infos = sel.xpath(<span class="string">'//tr[count(td)=6]'</span>)</div><div class="line">	<span class="keyword">for</span> info <span class="keyword">in</span> infos.xpath(<span class="string">'.//td'</span>):</div><div class="line">		<span class="keyword">pass</span></div></pre></td></tr></table></figure>

<p><a href="https://github.com/Abbeychenxi/cosjy" target="_blank" rel="external">代码git地址</a></p>
<h1 id="存储内容">存储内容</h1>
<p>保存信息的最简单的方法是通过Feed exports，主要有四种：JSON，JSON lines，CSV，XML。<br>我们将结果用最常用的JSON导出</p>
<p><code>scrapy crawl manzhan -o items.json -t json</code></p>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="Scrapy" scheme="http://www.abbeychenxi.net/tags/Scrapy/"/>
    
      <category term="cosjy" scheme="http://www.abbeychenxi.net/categories/cosjy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[node异步开发难题]]></title>
    <link href="http://www.abbeychenxi.net/2014/10/07/node%E5%BC%82%E6%AD%A5%E5%BC%80%E5%8F%91%E9%9A%BE%E9%A2%98/"/>
    <id>http://www.abbeychenxi.net/2014/10/07/node异步开发难题/</id>
    <published>2014-10-07T14:36:10.000Z</published>
    <updated>2014-10-25T14:34:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="作用域导致bug">作用域导致bug</h2>
<p>javascript闭包可以“冻结”变量的值，调用的时候将变量值封装到匿名函数里。这样可以马上执行这个匿名函数，把当前的color的值传给它。而color变成了匿名函数的参数，成为匿名函数的本地变量，所以外部的color变化时，不会影响到本地的color值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span><span class="params">(callback)</span> </span>{</div><div class="line">	setTimeout(<span class="keyword">callback</span>, <span class="number">200</span>);</div><div class="line">}</div><div class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(color)</span> </span>{</div><div class="line">	asyncFunction(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">		console.log(<span class="string">'xxxx'</span>);</div><div class="line">	}) </div><div class="line">})(color);</div><div class="line"></div><div class="line">color = <span class="string">'green'</span>;</div></pre></td></tr></table></figure>

<h2 id="Nimble实现串行化控制">Nimble实现串行化控制</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flow = <span class="built_in">require</span>(<span class="string">'nimble'</span>);</div><div class="line"></div><div class="line">flow.series([</div><div class="line">	<span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>{</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">			callback();</div><div class="line">		}, <span class="number">1000</span>)</div><div class="line">	},</div><div class="line">	<span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>{</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">			callback();</div><div class="line">		}, <span class="number">500</span>)</div><div class="line">	}	</div><div class="line">]);</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="node.js" scheme="http://www.abbeychenxi.net/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python在函数中接收元组和列表]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/29/Python%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8E%A5%E6%94%B6%E5%85%83%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8/"/>
    <id>http://www.abbeychenxi.net/2014/09/29/Python在函数中接收元组和列表/</id>
    <published>2014-09-29T13:02:11.000Z</published>
    <updated>2014-10-25T18:30:53.000Z</updated>
    <content type="html"><![CDATA[<p>当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，分别使用<em>和*</em>前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">powersum</span><span class="params">(power, *args)</span>:</span></div><div class="line">	total = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> args:</div><div class="line">		total += pow(i. power)</div><div class="line">	<span class="keyword">return</span> total</div><div class="line"></div><div class="line">power(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure>

<p>由于在args变量前有<em>前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是*</em>前缀，多余的参数则会被认为是一个字典的键/值对。</p>
<h2 id="lambda形式">lambda形式</h2>
<p>用来创建新的函数对象，并在运行时返回它们。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_repeater</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span> s: s*n</div><div class="line">	</div><div class="line">twice = make_repeater(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> twice(<span class="string">'word'</span>)</div><div class="line"><span class="keyword">print</span> twice(<span class="number">5</span>)</div></pre></td></tr></table></figure>

<h2 id="exec和eval语句">exec和eval语句</h2>
<p>exec语句用来执行储存在字符串或文件中的Python语句。<br><code>exec &#39;print &quot;Hello World&quot;&#39;</code></p>
<p>eval语句用来计算存储在字符串中的有效Python表达式。<br><code>eval(&#39;2*3&#39;)</code></p>
<h2 id="repr函数">repr函数</h2>
<p>repr函数用来取得对象的规范字符串表。<br><code>eval (repr(object)) == object</code></p>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python 储存器]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/29/Python-%E5%82%A8%E5%AD%98%E5%99%A8/"/>
    <id>http://www.abbeychenxi.net/2014/09/29/Python-储存器/</id>
    <published>2014-09-29T12:37:41.000Z</published>
    <updated>2014-10-25T18:31:05.000Z</updated>
    <content type="html"><![CDATA[<p>Python提供一个标准的模块，称为pickle。使用它可以在一个文件中储存任何Python对象，之后你又可以把它完整无缺地取出来。被称为持久地储存对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cPickle <span class="keyword">as</span> <span class="keyword">p</span></div><div class="line"></div><div class="line">shoplistfile = <span class="string">'shoplist.data'</span></div><div class="line"></div><div class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>]</div><div class="line"></div><div class="line"><span class="keyword">f</span> = <span class="keyword">file</span>(shoplistfile, <span class="string">'w'</span>)</div><div class="line"><span class="keyword">p</span>.dump(shoplist, <span class="keyword">f</span>)</div><div class="line"><span class="keyword">f</span>.<span class="keyword">close</span>()</div></pre></td></tr></table></figure>

<h2 id="异常处理">异常处理</h2>
<h1 id="使用try…except_语句来处理异常。把通常的语句放在try块中，而把我们的错误处理放在except块中。">使用try…except 语句来处理异常。把通常的语句放在try块中，而把我们的错误处理放在except块中。</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	s = raw_input(<span class="string">'Enter something --&gt; '</span>)</div><div class="line"><span class="keyword">except</span> EOFError:</div><div class="line">	<span class="keyword">print</span> <span class="string">''</span></div><div class="line">	sys.exit()</div><div class="line"><span class="keyword">except</span>:</div><div class="line">	<span class="keyword">print</span> <span class="string">''</span></div><div class="line">	</div><div class="line"><span class="keyword">print</span> <span class="string">'Done'</span></div></pre></td></tr></table></figure>

<h1 id="try…finally">try…finally</h1>
<p>读一个文件时，希望无论异常发送与否的情况下都关闭文件。使用finally块来实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import <span class="built_in">time</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	f = <span class="built_in">file</span>(<span class="string">'poem.txt'</span>)</div><div class="line">	<span class="keyword">while</span> True:</div><div class="line">		<span class="built_in">line</span> = f.readline()</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">line</span>) == <span class="number">0</span>:</div><div class="line">			break</div><div class="line">		<span class="built_in">time</span>.sleep(<span class="number">2</span>)</div><div class="line">		print <span class="built_in">line</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">	f.<span class="built_in">close</span>()</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python 数据结构]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/29/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.abbeychenxi.net/2014/09/29/Python-数据结构/</id>
    <published>2014-09-29T04:02:43.000Z</published>
    <updated>2014-10-25T18:31:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="对象与参考">对象与参考</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</div><div class="line">mylist = shoplist</div><div class="line"></div><div class="line"><span class="keyword">del</span> shoplist[<span class="number">0</span>]</div><div class="line"></div><div class="line">mylist = shoplist[:]</div><div class="line"></div><div class="line"><span class="keyword">del</span> mylist[<span class="number">0</span>]</div></pre></td></tr></table></figure>

<p>如果要复制一个列表或者类似的序列或者其他复杂的对象，必须使用切片操作符来取得拷贝。如果只是想要使用另外一个变量名，两个变量名称都参考同一个对象，那么如果不小心，会引来各种麻烦。</p>
<h2 id="更多字符串的内容">更多字符串的内容</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">name = <span class="string">'Swaroop'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> name.startwith(<span class="string">'Swa'</span>):</div><div class="line">	<span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">in</span> name:</div><div class="line">	<span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> name.find(<span class="string">'war'</span>) != -<span class="number">1</span>:</div><div class="line">	<span class="keyword">pass</span></div><div class="line"></div><div class="line">delimiter = <span class="string">'_*_'</span></div><div class="line">mylist = [<span class="string">'russia'</span>, <span class="string">'india'</span>]</div><div class="line">delimter.join(mylist)</div></pre></td></tr></table></figure>

<p>str类也有以一个作为分隔符的字符串join序列的项目的整洁的方法，它返回一个生成的大字符串。</p>
<h2 id="软件开发过程">软件开发过程</h2>
<ol>
<li>分析</li>
<li>设计</li>
<li>实施</li>
<li>测试与调试</li>
<li>实施或开发</li>
<li>优化</li>
</ol>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 入门]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/23/Node-js-%E5%85%A5%E9%97%A8/"/>
    <id>http://www.abbeychenxi.net/2014/09/23/Node-js-入门/</id>
    <published>2014-09-23T11:43:54.000Z</published>
    <updated>2014-10-25T18:30:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一个完整的基于Node-js的web应用">一个完整的基于Node.js的web应用</h2>
<h1 id="用例">用例</h1>
<ul>
<li>用户通过浏览器使用我们的应用。</li>
<li>当用户请求<a href="http://domain/start时，" target="_blank" rel="external">http://domain/start时，</a> 可以看到一个欢迎页面，页面上有一个文件上传的表单。</li>
<li>用户可以选择一个图片并提交表单，随后文件将被上传到<a href="http://domain/upload,该页面完成上传后会把图片显示在页面上。" target="_blank" rel="external">http://domain/upload,该页面完成上传后会把图片显示在页面上。</a></li>
</ul>
<h1 id="应用不同模块分析">应用不同模块分析</h1>
<ul>
<li>需要提供Web页面，因此需要一个HTTP服务器</li>
<li>对于不同的请求，根据请求的URL，我们服务器给予不同的响应，因此需要一个路由，用于把请求对应到请求处理程序</li>
<li>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，需要最终的请求处理程序</li>
<li>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理程序，因此需要请求数据处理功能</li>
<li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器</li>
<li>最后，用户需要上传图片，所以需要上传处理功能</li>
</ul>
<h1 id="一个基础的HTTP服务器">一个基础的HTTP服务器</h1>
<p>服务器模块：创建一个server.js</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(<span class="string">"http"</span>);</div><div class="line">http.createServer(<span class="keyword">function</span>(<span class="built_in">request</span>, <span class="built_in">response</span>) {</div><div class="line">	<span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">	<span class="built_in">response</span>.write(<span class="string">"Hello World"</span>);</div><div class="line">	<span class="built_in">response</span>.<span class="keyword">end</span>();</div><div class="line">}).listen(<span class="number">8888</span>);</div></pre></td></tr></table></figure>

<h1 id="分析HTTP服务器">分析HTTP服务器</h1>
<p>引入一个http模块并复制给http变量，接下来调用createServer函数。<br>这个函数返回一个对象，并调用listen方法，指定http服务器监听的端口号。</p>
<h1 id="函数传递">函数传递</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(someFunction, value)</span> </span>{</div><div class="line">	someFunction(value);</div><div class="line">}</div><div class="line"></div><div class="line">excute(<span class="function"><span class="keyword">function</span><span class="params">(word)</span> </span>{<span class="built_in">console</span>.log (word) }, <span class="string">"hello"</span>);</div></pre></td></tr></table></figure>

<h1 id="函数传递是如何让HTTP服务器工作的">函数传递是如何让HTTP服务器工作的</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var http = require(<span class="string">"http"</span>);</div><div class="line"></div><div class="line"><span class="keyword">function</span> onRequest(<span class="built_in">request</span>, <span class="built_in">response</span>) {</div><div class="line">	<span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">	<span class="built_in">response</span>.write(<span class="string">"hello world"</span>);</div><div class="line">	<span class="built_in">response</span>.<span class="keyword">end</span>();</div><div class="line">}</div><div class="line"></div><div class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</div></pre></td></tr></table></figure>

<h1 id="基于事件的驱动回调">基于事件的驱动回调</h1>
<p><a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" target="_blank" rel="external">Understanding node.js</a>介绍了一些背景知识。</p>
<p>服务器收到HTTP请求的时候是异步的，请求任何时候都可能到达，但是我们服务器却跑在一个单进程中。</p>
<h1 id="服务器是如何处理请求的">服务器是如何处理请求的</h1>
<p>收到请求的时候，使用reponse.writeHead()函数发送一个HTTP状态200和HTTP头的内容类型，使用response.write()函数在HTTP相应主体中发送文本“Hello World”。<br>最后，调用response.end()完成响应。</p>
<p>把服务器脚本放到一个start函数里，然后导出这个函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> </span>{</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">(request, response)</span> </span>{</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"Request received."</span>);</div><div class="line">		response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">		response.write(<span class="string">"Hello World"</span>);</div><div class="line">		response.end();</div><div class="line">	}</div><div class="line">	http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure>

<p>在index.js文件中写入：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</div><div class="line"></div><div class="line">server.start();</div></pre></td></tr></table></figure>

<h1 id="如何来进行请求的“路由”">如何来进行请求的“路由”</h1>
<p>数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。为了解析这些数据，需要额外的Node.js模块，分别是url和querystring模块。</p>
<pre><code>                           url.parse(string).query
                                       <span class="string">|</span>
       url.parse(string).pathname      <span class="string">|</span>
                   <span class="string">|                   |</span>
                   <span class="string">|                   |</span>
                 ------ -------------------
http:<span class="comment">//localhost:8888/start?foo=bar&amp;hello=world</span>
                            ---       -----
                             <span class="string">|          |</span>
                             <span class="string">|          |</span>
          querystring(string)[<span class="string">"foo"</span>]    <span class="string">|</span>
                                        <span class="string">|</span>
                     querystring(string)[<span class="string">"hello"</span>]
</code></pre><p>现在给onRequest()函数加上逻辑，用来找出浏览器请求的URL路径:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> </span>{</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">(request, response)</span> </span>{</div><div class="line">		<span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line">		response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">		response.write(<span class="string">"Hello World"</span>);</div><div class="line">		response.end();</div><div class="line">	}</div><div class="line">	http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure>

<p>编写路由：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span><span class="params">(pathname)</span> </span>{</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">}</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure>

<p>服务器应当知道路由的存在并且加以利用。可以使用依赖注入的方式较松散地添加路由模块。<a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="external">Martin Fowlers 关于依赖注入</a>的文章来作为背景知识。</p>
<p>扩展start()函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(route)</span> </span>{</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">(request, response)</span> </span>{</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    route(pathname);</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">  }</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure>

<p>相应的扩展index.js，使得路由函数可以被注入到服务器中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</div><div class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</div><div class="line"></div><div class="line">server.start(router.route);</div></pre></td></tr></table></figure>

<h1 id="行为驱动执行">行为驱动执行</h1>
<p>Steve Yegge<a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" target="_blank" rel="external">名词王国中的死刑</a>帮助理解函数编程</p>
<h1 id="路由给真正的请求处理程序">路由给真正的请求处理程序</h1>
<p>创建一个requestHandlers的模块：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> </span>{</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span><span class="params">()</span> </span>{</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure>

<p>在javascript中，对象就是一个键/值对的集合—你可以把javascript的对象想象成一个键为字符串类型的字典。</p>
<p>将对象引入到index.js：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> server <span class="subst">=</span> <span class="keyword">require</span>(<span class="string">"./server"</span>);</div><div class="line"><span class="built_in">var</span> router <span class="subst">=</span> <span class="keyword">require</span>(<span class="string">"./router"</span>);</div><div class="line"><span class="built_in">var</span> requestHandlers <span class="subst">=</span> <span class="keyword">require</span>(<span class="string">"./requestHandlers"</span>);</div><div class="line"></div><div class="line"><span class="built_in">var</span> <span class="keyword">handle</span> <span class="subst">=</span> {};</div><div class="line"><span class="keyword">handle</span><span class="preprocessor">[</span><span class="string">"/"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.start;</span></div><div class="line">handle<span class="preprocessor">[</span><span class="string">"/start"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.start;</span></div><div class="line">handle<span class="preprocessor">[</span><span class="string">"/upload"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.upload;</span></div><div class="line"></div><div class="line">server.start(router.route, handle);</div></pre></td></tr></table></figure>

<p>完成了对象的定义之后，把它作为额外的参数传递给服务器，将server.js修改如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(route, handle)</span> </span>{</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">(request, response)</span> </span>{</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    route(handle, pathname);</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">  }</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure>

<p>这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。<br>修改route.js文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span><span class="params">(handle, pathname)</span> </span>{</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) {</div><div class="line">    handle[pathname]();</div><div class="line">  } <span class="keyword">else</span> {</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure>

<h1 id="阻塞与非阻塞">阻塞与非阻塞</h1>
<p><a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="external">理解node.js的事件轮询</a></p>
<p>简单又实用的非阻塞操作exec()</p>
<h2 id="以非阻塞操作进行请求响应">以非阻塞操作进行请求响应</h2>
<p>Node.js的实现方案:函数传递。<br>将内容传递给服务器的方式，将服务器“传递”给内容的方式。<br>就是将response对象通过请求路由传递给请求处理程序。随后，处理程序就可以采用该对象上的函数来对请求作出响应。<br>从server.js开始：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(route, handle)</span> </span>{</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">(request, response)</span> </span>{</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    route(handle, pathname, response);</div><div class="line">  }</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure>

<p>将response对象作为第三个参数传递给route()函数，并且，将onRequest()处理程序中所有有关response的函数调用都移除，因为这部分工作让route()函数完成。</p>
<p>router.js：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> route(handle, pathname, <span class="built_in">response</span>) {</div><div class="line">	console.<span class="built_in">log</span>(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">	<span class="keyword">if</span>(typeof handle[pathname] === <span class="comment">'function') {</span></div><div class="line">		handle[pathname](<span class="built_in">response</span>);</div><div class="line">	}<span class="keyword">else</span> {</div><div class="line">		console.<span class="built_in">log</span>(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">    <span class="built_in">response</span>.writeHead(<span class="number">404</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">    <span class="built_in">response</span>.write(<span class="string">"404 Not found"</span>);</div><div class="line">    <span class="built_in">response</span>.<span class="keyword">end</span>();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure>

<p>将requestHandler.js修改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var exec = require(<span class="string">"child_process"</span>).exec;</div><div class="line"></div><div class="line"><span class="keyword">function</span> start(<span class="built_in">response</span>) {</div><div class="line">  console.<span class="built_in">log</span>(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  exec(<span class="string">"ls -lah"</span>, <span class="keyword">function</span> (<span class="keyword">error</span>, stdout, stderr) {</div><div class="line">    <span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">    <span class="built_in">response</span>.write(stdout);</div><div class="line">    <span class="built_in">response</span>.<span class="keyword">end</span>();</div><div class="line">  });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">function</span> upload(<span class="built_in">response</span>) {</div><div class="line">  console.<span class="built_in">log</span>(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  <span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">  <span class="built_in">response</span>.write(<span class="string">"Hello Upload"</span>);</div><div class="line">  <span class="built_in">response</span>.<span class="keyword">end</span>();</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure>

<h1 id="更有用的场景">更有用的场景</h1>
<ul>
<li>尽管Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多</li>
<li>用Node.js来处理文件上传比较复杂</li>
</ul>
<h1 id="处理POST请求">处理POST请求</h1>
<p>将requestHandlers.js修改为如下形式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(response)</span> {</span></div><div class="line">  <span class="transposed_variable">console.</span>log(<span class="string">"Request handler '</span><span class="transposed_variable">start'</span> was <span class="transposed_variable">called.</span><span class="string">");</span></div><div class="line"></div><div class="line">  var body = '&lt;html&gt;<span class="string">'+</span></div><div class="line">    '&lt;head&gt;<span class="string">'+</span></div><div class="line">    '&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; '</span>+</div><div class="line">    <span class="string">'charset=UTF-8"</span> /&gt;<span class="string">'+</span></div><div class="line">    '&lt;/head&gt;<span class="string">'+</span></div><div class="line">    '&lt;body&gt;<span class="string">'+</span></div><div class="line">    '&lt;form action=<span class="string">"/upload"</span> method=<span class="string">"post"</span>&gt;<span class="string">'+</span></div><div class="line">    '&lt;textarea name=<span class="string">"text"</span> rows=<span class="string">"20"</span> cols=<span class="string">"60"</span>&gt;&lt;/textarea&gt;<span class="string">'+</span></div><div class="line">    '&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit text"</span> /&gt;<span class="string">'+</span></div><div class="line">    '&lt;/form&gt;<span class="string">'+</span></div><div class="line">    '&lt;/body&gt;<span class="string">'+</span></div><div class="line">    '&lt;/html&gt;<span class="string">';</span></div><div class="line"></div><div class="line">    response.writeHead(200, {"Content-Type<span class="string">": "</span>text/html<span class="string">"});</span></div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">}</div><div class="line"></div><div class="line">function upload(response) {</div><div class="line">  console.log("Request handler <span class="string">'upload'</span> was <span class="transposed_variable">called.</span><span class="string">");</span></div><div class="line">  response.writeHead(200, {"Content-Type<span class="string">": "</span>text/plain<span class="string">"});</span></div><div class="line">  response.write("Hello Upload<span class="string">");</span></div><div class="line">  response.end();</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure>

<p>为了使得整个过程非阻塞，Node.js会将POST数据拆分成很多小块，然后通过触发特定的事件，将这些小数据库传递给回调函数。</p>
<p>我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。通过在request对象上注册监听器来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">request.addListener(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> </span>{</div><div class="line">  <span class="comment">// called when a new chunk of data was received</span></div><div class="line">});</div><div class="line"></div><div class="line">request.addListener(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">  <span class="comment">// called when all chunks of data have been received</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>从server.js开始：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(route, handle)</span> </span>{</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">(request, response)</span> </span>{</div><div class="line">    <span class="keyword">var</span> postData = <span class="string">""</span>;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    request.setEncoding(<span class="string">"utf8"</span>);</div><div class="line"></div><div class="line">    request.addListener(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span><span class="params">(postDataChunk)</span> </span>{</div><div class="line">      postData += postDataChunk;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Received POST data chunk '"</span>+</div><div class="line">      postDataChunk + <span class="string">"'."</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    request.addListener(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">      route(handle, pathname, response, postData);</div><div class="line">    });</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure>

<p>上述代码做了三件事情：</p>
<ul>
<li>设置了接收数据的编码格式为UTF-8</li>
<li>注册了“data”事件的监听器，用于收集每次接收到的新数据块，并赋值给postData变量</li>
<li>将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。同时把POST数据传递给请求路由，因为数据，请求处理程序会用到</li>
</ul>
<p>在upload页面，展示用户输入的内容。修改router.js：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> route(handle, pathname, <span class="built_in">response</span>, postData) {</div><div class="line">  console.<span class="built_in">log</span>(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">  <span class="keyword">if</span> (typeof handle[pathname] === <span class="comment">'function') {</span></div><div class="line">    handle[pathname](<span class="built_in">response</span>, postData);</div><div class="line">  } <span class="keyword">else</span> {</div><div class="line">    console.<span class="built_in">log</span>(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">    <span class="built_in">response</span>.writeHead(<span class="number">404</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">    <span class="built_in">response</span>.write(<span class="string">"404 Not found"</span>);</div><div class="line">    <span class="built_in">response</span>.<span class="keyword">end</span>();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure>

<p>然后，在requestHandler.js中，将数据包含在对upload请求的响应中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(response, postData)</span> {</span></div><div class="line">  <span class="transposed_variable">console.</span>log(<span class="string">"Request handler '</span><span class="transposed_variable">start'</span> was <span class="transposed_variable">called.</span><span class="string">");</span></div><div class="line"></div><div class="line">  var body = '&lt;html&gt;<span class="string">'+</span></div><div class="line">    '&lt;head&gt;<span class="string">'+</span></div><div class="line">    '&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; '</span>+</div><div class="line">    <span class="string">'charset=UTF-8"</span> /&gt;<span class="string">'+</span></div><div class="line">    '&lt;/head&gt;<span class="string">'+</span></div><div class="line">    '&lt;body&gt;<span class="string">'+</span></div><div class="line">    '&lt;form action=<span class="string">"/upload"</span> method=<span class="string">"post"</span>&gt;<span class="string">'+</span></div><div class="line">    '&lt;textarea name=<span class="string">"text"</span> rows=<span class="string">"20"</span> cols=<span class="string">"60"</span>&gt;&lt;/textarea&gt;<span class="string">'+</span></div><div class="line">    '&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit text"</span> /&gt;<span class="string">'+</span></div><div class="line">    '&lt;/form&gt;<span class="string">'+</span></div><div class="line">    '&lt;/body&gt;<span class="string">'+</span></div><div class="line">    '&lt;/html&gt;<span class="string">';</span></div><div class="line"></div><div class="line">    response.writeHead(200, {"Content-Type<span class="string">": "</span>text/html<span class="string">"});</span></div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">}</div><div class="line"></div><div class="line">function upload(response, postData) {</div><div class="line">  console.log("Request handler <span class="string">'upload'</span> was <span class="transposed_variable">called.</span><span class="string">");</span></div><div class="line">  response.writeHead(200, {"Content-Type<span class="string">": "</span>text/plain<span class="string">"});</span></div><div class="line">  response.write("<span class="transposed_variable">You'</span>ve sent: <span class="string">" + postData);</span></div><div class="line">  response.end();</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure>

<p>最后做的是：我们是把请求的整个消息传递给了请求路由和请求处理程序。我们应该只把POST数据中，感兴趣的部分传递给请求路由和请求处理程序。</p>
<p>querystring模块：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">var querystring = require(<span class="string">"querystring"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(response, postData)</span> {</span></div><div class="line">  <span class="transposed_variable">console.</span>log(<span class="string">"Request handler '</span><span class="transposed_variable">start'</span> was <span class="transposed_variable">called.</span><span class="string">");</span></div><div class="line"></div><div class="line">  var body = '&lt;html&gt;<span class="string">'+</span></div><div class="line">    '&lt;head&gt;<span class="string">'+</span></div><div class="line">    '&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; '</span>+</div><div class="line">    <span class="string">'charset=UTF-8"</span> /&gt;<span class="string">'+</span></div><div class="line">    '&lt;/head&gt;<span class="string">'+</span></div><div class="line">    '&lt;body&gt;<span class="string">'+</span></div><div class="line">    '&lt;form action=<span class="string">"/upload"</span> method=<span class="string">"post"</span>&gt;<span class="string">'+</span></div><div class="line">    '&lt;textarea name=<span class="string">"text"</span> rows=<span class="string">"20"</span> cols=<span class="string">"60"</span>&gt;&lt;/textarea&gt;<span class="string">'+</span></div><div class="line">    '&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit text"</span> /&gt;<span class="string">'+</span></div><div class="line">    '&lt;/form&gt;<span class="string">'+</span></div><div class="line">    '&lt;/body&gt;<span class="string">'+</span></div><div class="line">    '&lt;/html&gt;<span class="string">';</span></div><div class="line"></div><div class="line">    response.writeHead(200, {"Content-Type<span class="string">": "</span>text/html<span class="string">"});</span></div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">}</div><div class="line"></div><div class="line">function upload(response, postData) {</div><div class="line">  console.log("Request handler <span class="string">'upload'</span> was <span class="transposed_variable">called.</span><span class="string">");</span></div><div class="line">  response.writeHead(200, {"Content-Type<span class="string">": "</span>text/plain<span class="string">"});</span></div><div class="line">  response.write("<span class="transposed_variable">You'</span>ve sent the text: <span class="string">"+</span></div><div class="line">  querystring.parse(postData).text);</div><div class="line">  response.end();</div><div class="line">}</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure>

<h2 id="处理文件上传">处理文件上传</h2>
<p>外部模块：Felix Geisendorfer开发的node-formidable模块。</p>
<ul>
<li>在/start表单中添加一个文件上传元素</li>
<li>将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到./test.png</li>
<li>将上传的图片内嵌到/uploadURL输出的HTML中</li>
</ul>
<p>将request对象从服务器开始一路通过请求路由，在传递给请求处理程序。</p>
<p>我们可以将postData从服务器以及请求处理程序中移除—对于我们处理文件上传来说不需要了，另一方面，Node.js不会对数据做缓存</p>
<p>采用fs.renameSync(path1, path2)实现将文件保存到本地目录下</p>
<h2 id="总结与展望">总结与展望</h2>
<p>本书没有涉及到的：如何操作数据库，如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。</p>
]]></content>
    
    
      <category term="node.js" scheme="http://www.abbeychenxi.net/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大教堂与市集-开放源代码软件]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/18/%E5%A4%A7%E6%95%99%E5%A0%82%E4%B8%8E%E5%B8%82%E9%9B%86-%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.abbeychenxi.net/2014/09/18/大教堂与市集-开放源代码软件/</id>
    <published>2014-09-18T06:25:54.000Z</published>
    <updated>2014-10-25T14:34:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="《大教堂与市集》-开放源代码运动的《圣经》">《大教堂与市集》-开放源代码运动的《圣经》</h2>
<ul>
<li>并行的、点对点的、动态的开发模式（开源）</li>
<li>封闭的、垂直的、集中式的开发模式（大教堂）</li>
</ul>
<h2 id="Linux">Linux</h2>
<h2 id="problem">problem</h2>
<ol>
<li>opensource软件是不是免费的？</li>
<li>买的软件到底是什么？-使用权</li>
</ol>
<h2 id="Fetchmail">Fetchmail</h2>
<h2 id="拥有用户的重要性">拥有用户的重要性</h2>
<ol>
<li>每个好的软件工作都开始于搔到了开发者本人的痒处</li>
<li>好程序员知道该写什么，伟大的程序员知道该重写什么</li>
<li>“计划好抛弃，无论如何，你会的”</li>
<li>如果你有正确的态度，有趣的问题会找上你的</li>
<li>pass</li>
<li>把用户当做协作开发者是快速改进代码和高效调试的无可争辩的方式</li>
</ol>
<h2 id="早发布、常发布">早发布、常发布</h2>
<h2 id="Linus定律">Linus定律</h2>
<ul>
<li>如果有一个足够大的beta测试人员和协作开发人员的基础，几乎所有的问题都可以被快速的找出并被一些人纠正</li>
</ul>
<h2 id="Delphi效应—一群相同专业的观察者的平均观点比在其中随机挑选一个来得更加可靠">Delphi效应—一群相同专业的观察者的平均观点比在其中随机挑选一个来得更加可靠</h2>
<ul>
<li>Delphi效应甚至可以战胜操作系统内核一级的复杂度</li>
<li>Delphi估算法</li>
</ul>
<h2 id="现象">现象</h2>
<ul>
<li>现在高科技公司投入巨额资金发展开源软件，而通常开源软件本身免费。<ul>
<li>google:Android, Chrome</li>
<li>IMB:Eclipse</li>
<li>Intel:Linux</li>
</ul>
</li>
<li>这些公司并不是放弃资本主义，而是认为这是个好的商业策略</li>
</ul>
<h2 id="替代物品和互补物品">替代物品和互补物品</h2>
<ul>
<li>市场上所有的产品都有替代物品和互补物品<ul>
<li>替代物品是首选商品太贵时会</li>
</ul>
</li>
</ul>
]]></content>
    
    
      <category term="NJU" scheme="http://www.abbeychenxi.net/tags/NJU/"/>
    
      <category term="软件工程管理" scheme="http://www.abbeychenxi.net/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[No Silver Bullet]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/15/No-Silver-Bullet/"/>
    <id>http://www.abbeychenxi.net/2014/09/15/No-Silver-Bullet/</id>
    <published>2014-09-15T06:20:40.000Z</published>
    <updated>2014-10-25T14:34:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="复杂度">复杂度</h2>
<h2 id="一致性">一致性</h2>
<ul>
<li>物理学家面对异常复杂的事物，他们坚信必定存在着某种通用原理。物理学是研究上帝创造的东西</li>
<li>软件开发面对的复杂度往往是随心所欲、毫无规则可言的，来自若干必须遵循的人为惯例和系统。软件开发面对的是人，不是上帝。</li>
<li>很多复杂性来自保持与其它接口的一致</li>
</ul>
<h2 id="可变性">可变性</h2>
<ul>
<li>软件实体经常会遭受到持续的变更压力。<ul>
<li>汽车、建筑可以修改，但是很少有人修改，大家都知道成本很高</li>
<li>软件包含了很多功能</li>
<li>软件可以很容易地进行修改—-它是纯粹思维活动的产物，可以无限扩展</li>
</ul>
</li>
<li>软件变更<ul>
<li>人们要求扩展，更改功能</li>
<li>硬件的变化</li>
</ul>
</li>
<li>软件与整个社会联成一体，后者在不断变动，它强迫软件也跟着变动</li>
</ul>
<h2 id="不可见性">不可见性</h2>
<ul>
<li>软件是不可见的和无法可视化的<ul>
<li>抽象的功能：几何抽象、机械制图、化学分子模型</li>
<li>pass</li>
<li>这限制了个人的设计过程，也严重的阻碍了相互之间的交流</li>
<li>UML</li>
</ul>
</li>
</ul>
<h2 id="没有银弹">没有银弹</h2>
<ul>
<li>相对必要任务而言，软件工程师在次要任务上花费了多少时间和精力？除非它占了所有工作的9/10，否则即使全部次要任务的时间缩减到0，也不会给生成率带来数量级上的提高</li>
</ul>
<h2 id="“自动”编程">“自动”编程</h2>
<h2 id="图形化编程">图形化编程</h2>
<ul>
<li>流程图是一直非常差劲软件结构表达方法。</li>
<li>现在的屏幕非常小，像素级别，无法同时表现软件图形的所有正式、详细的范围和细节。</li>
<li>软件非常难以可视化。</li>
</ul>
<h2 id="程序验证">程序验证</h2>
<ul>
<li>是否有可能出现银弹，能够在系统设计级别、源代码级别消除bug呢？是否可以在大量工作被投入到实现和测试之前，通过采用证实设计正确性的“深奥”策略，彻底提高软件的生产率。</li>
<li>不能保证节约劳动力</li>
<li>程序验证不意味着0缺陷的程序</li>
<li>完美的程序验证只能建立满足技术说明的程序，而这时，软件工作过程中最困难的部分已经接近完成，形成了完整的和一致的说明。</li>
</ul>
<h2 id="环境和工具">环境和工具</h2>
<ul>
<li>IDE</li>
<li>这样的工作是非常有价值的，它能够带来软件生产率和可靠性上的一些提高。但是，由于它自身的特性，目前它的回报很有限。</li>
</ul>
<h2 id="工作站">工作站</h2>
<ul>
<li>硬件速度的加速</li>
<li>编译速度，开发速度</li>
<li>1986！</li>
</ul>
<h2 id="购买和自行开发">购买和自行开发</h2>
<ul>
<li>构建软件最可能的彻底解决方案是不开发任何软件</li>
<li>通用软件</li>
<li>1986！</li>
</ul>
<h2 id="需求精炼和快速原型">需求精炼和快速原型</h2>
<ul>
<li>概念性工作中。。。。</li>
</ul>
<h2 id="增量开发">增量开发</h2>
<ul>
<li>Grow not building</li>
<li>客户</li>
<li>士气</li>
<li>迭代式开发</li>
</ul>
<h2 id="卓越的设计人员">卓越的设计人员</h2>
<ul>
<li>软件开发是一个创造性的过程</li>
</ul>
<h2 id="没有银弹的影响">没有银弹的影响</h2>
<ul>
<li>软件开发本质的认识</li>
<li>软件过程</li>
</ul>
]]></content>
    
    
      <category term="NJU" scheme="http://www.abbeychenxi.net/tags/NJU/"/>
    
      <category term="软件工程管理" scheme="http://www.abbeychenxi.net/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MEAN.js]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/11/MEANjs/"/>
    <id>http://www.abbeychenxi.net/2014/09/11/MEANjs/</id>
    <published>2014-09-11T11:23:46.000Z</published>
    <updated>2014-10-25T14:34:21.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>MongoDB - Go through MongoDB Official Website and proceed to their Official Manual, which should help you understand NoSQL and MongoDB better.</li>
<li>Express - The best way to understand express is through its Official Website, particularly The Express Guide; you can also go through this StackOverflow Thread for more resources.</li>
<li>AngularJS - Angular’s Official Website is a great starting point. You can also use Thinkster Popular Guide, and the Egghead Videos.</li>
<li>Node.js - Start by going through Node.js Official Website and this StackOverflow Thread, which should get you going with the Node.js platform in no time.</li>
</ul>
]]></content>
    
    
      <category term="MEAN.js" scheme="http://www.abbeychenxi.net/tags/MEAN-js/"/>
    
      <category term="Full-Stack" scheme="http://www.abbeychenxi.net/tags/Full-Stack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python网络爬虫[七]]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/07/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%5B%E4%B8%83%5D/"/>
    <id>http://www.abbeychenxi.net/2014/09/07/Python网络爬虫[七]/</id>
    <published>2014-09-07T04:50:49.000Z</published>
    <updated>2014-10-25T14:35:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="正则表达式基础">正则表达式基础</h1>
<hr>
<h2 id="概念">概念</h2>
<p>正则表达式的大致匹配过程是：</p>
<ol>
<li>依次拿出表达式和文本中的字符比较。</li>
<li>如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。</li>
<li>如果表达式中有量词或边界，这个过程会稍微有一些不同。</li>
</ol>
<p>python支持的正则表达式元字符和语法:<br><img src="http://img.blog.csdn.net/20130515113723855" alt="image"></p>
<h2 id="数量词的贪婪模式与非贪婪模式">数量词的贪婪模式与非贪婪模式</h2>
<p>正则表达式通常用于在文本中查找匹配的字符串。<br>贪婪模式，总是尝试匹配尽可能多的字符；<br>非贪婪模式则相反，总是尝试匹配尽可能少的字符。</p>
<h2 id="反斜杠问题">反斜杠问题</h2>
<p>Python原生字符串可以使用r”\“表示”\”。</p>
<h1 id="re模块">re模块</h1>
<hr>
<h2 id="Compile">Compile</h2>
<p>使用re步骤：</p>
<ol>
<li>先将正则表达式的字符串形式编译为Pattern实例。</li>
<li>然后使用Pattern实例处理文本并获得匹配结果。</li>
<li>最后使用Match实例获得信息，进行其他操作。</li>
</ol>
<h2 id="Match">Match</h2>
<p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>
<h2 id="Pattern">Pattern</h2>
<p>Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。<br>Pattern不能直接实例化，必须使用re.compile()进行构造，也就是re.compile()返回的对象。<br>Pattern提供了几个可读属性用于获取表达式的相关信息：</p>
<ol>
<li>pattern：编译时用的表达式字符串</li>
<li>flags： 编译时用的匹配模式。数字形式。</li>
<li>groups：表达式中分组的数量。</li>
<li>groupindex：以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 </li>
</ol>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.abbeychenxi.net/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python网络爬虫[五]]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/07/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%5B%E4%BA%94%5D/"/>
    <id>http://www.abbeychenxi.net/2014/09/07/Python网络爬虫[五]/</id>
    <published>2014-09-06T16:00:11.000Z</published>
    <updated>2014-10-25T14:35:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Proxy设置">Proxy设置</h2>
<p>在程序中明确Proxy不受环境变量的影响</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> urllib2</div><div class="line"><span class="variable">enable_proxy =</span> True</div><div class="line"><span class="variable">proxy_handler =</span> urllib2.ProxyHandler({<span class="string">"http"</span>: 'http://some-proxy.com:<span class="number">8080</span>'})</div><div class="line"><span class="variable">null_proxy_handler =</span> urllib2.ProxyHandler({})</div><div class="line"><span class="keyword">if</span> enable_proxy:</div><div class="line">	<span class="variable">opener =</span> urllib2.build_opener(proxy_handler)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	<span class="variable">opener =</span> urllib2.build_opener(null_proxy_handler)</div><div class="line">urllib2.install_opener(opener)</div></pre></td></tr></table></figure>

<h2 id="Timeout设置">Timeout设置</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> urllib2</div><div class="line"><span class="variable">response =</span> urllib2.urlopen('http://www.google.com', <span class="variable">timeout =</span> <span class="number">10</span>)</div></pre></td></tr></table></figure>

<h2 id="在HTTP_Request中加入特定的Header">在HTTP Request中加入特定的Header</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">request = urllib2.Request(<span class="string">'http://www.baidu.com/'</span>)</div><div class="line">request.add_handler(<span class="string">'User-Agent'</span>, <span class="string">'fake-client'</span>)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.<span class="keyword">read</span>()</div></pre></td></tr></table></figure>

<h2 id="Redirect">Redirect</h2>
<p>urllib2 默认情况下会针对HTTP 3XX返回码自动进行redirect动作，无需人工配置。要检测是否发送了Redirect动作，只要检查Response的URL和Request的URL是否一致。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> urllib2</div><div class="line"><span class="variable">my_url =</span> 'http://www.google.cn'</div><div class="line"><span class="variable">response =</span> urllib2.urlopen(my_url)</div><div class="line"><span class="variable">redirected =</span> response.geturl() == my_url</div><div class="line">print redirected</div><div class="line"></div><div class="line"><span class="variable">my_url =</span> 'http://rrurl.cn/blUZup'</div><div class="line"><span class="variable">response =</span> urllib2.urlopen(my_url)</div><div class="line"><span class="variable">redirected =</span> response.geturl() == my_url</div><div class="line">print redirected</div></pre></td></tr></table></figure>

<h2 id="Cookie">Cookie</h2>
<p>urllib2对Cookie的处理也是自动的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import urllib2</div><div class="line">import cookielib</div><div class="line">cookie = cookielib.CookieJar()</div><div class="line">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</div><div class="line">response = opener.<span class="built_in">open</span>(<span class="string">'http://www.baidu.com'</span>)</div><div class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> cookie:</div><div class="line">	print <span class="string">'Name = '</span>+<span class="keyword">item</span>.name</div><div class="line">	print <span class="string">'Value = '</span>+<span class="keyword">item</span>.<span class="built_in">value</span></div></pre></td></tr></table></figure>

<h2 id="使用HTTP的PUT和DELETE方法">使用HTTP的PUT和DELETE方法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> urllib2</div><div class="line"><span class="variable">request =</span> urllib2.Request(uri, <span class="variable">data =</span> data)</div><div class="line">request.<span class="variable">get_method =</span> lambda: 'PUT'</div><div class="line"><span class="variable">response =</span> urllib2.urlopen(request)</div></pre></td></tr></table></figure>

<h2 id="得到HTTP的返回码">得到HTTP的返回码</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">try</span>:</div><div class="line">	response = urllib2.urlopen(<span class="string">'http://bbs.csdn.net/why'</span>)</div><div class="line"><span class="keyword">except</span> urllib2.HTTPError, e:</div><div class="line">	<span class="keyword">print</span> e.code</div></pre></td></tr></table></figure>

<h2 id="Debug_Log">Debug Log</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> urllib2</div><div class="line"><span class="variable">httpHandler =</span> urllib2.HTTPHandler(<span class="variable">debuglevel =</span> <span class="number">1</span>)</div><div class="line"><span class="variable">httpsHandler =</span> urllib2.HTTPSHandler(<span class="variable">debuglevel =</span> <span class="number">1</span>)</div><div class="line"><span class="variable">opener =</span> urllib2.build_opener(httpHandler, httpsHandler)</div><div class="line">urllib2.install_opener(opener)</div><div class="line"><span class="variable">response =</span> urllib2.urlopen('http://www.google.com')</div></pre></td></tr></table></figure>

<h2 id="表单处理">表单处理</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">postdata = urllib.urlencode({</div><div class="line">	'username': 'chenxi',</div><div class="line">	'password': 'why888',</div><div class="line">	'fk': '',</div><div class="line">	'login_submit': '登录'</div><div class="line">})</div><div class="line">req = urllib2.<span class="type">Request</span> (</div><div class="line">	url = 'http://secure.verycd.com/signin',</div><div class="line">	data = postdata</div><div class="line">)</div><div class="line"><span class="literal">result</span> = urllib2.urlopen(req)</div><div class="line">print <span class="literal">result</span>.read()</div></pre></td></tr></table></figure>

<h2 id="伪装成浏览器访问">伪装成浏览器访问</h2>
<p>修改http包中的header来实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="constant">headers</span> = {</div><div class="line">	'User-Agent': 'Mozilla/5.0 (windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) gecko/20091201 Firefox/3.5.6'</div><div class="line">}</div><div class="line"><span class="constant">req</span> = urllib2.Request (</div><div class="line">	url = 'http://secure.verycd.com/signin/*/http://www.verycd.com/',</div><div class="line">	data = postdata,</div><div class="line">	headers = headers</div><div class="line">)</div></pre></td></tr></table></figure>

<h2 id="对付“反盗链”">对付“反盗链”</h2>
<p>把headers的referer改成该网站即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">headers = {</div><div class="line">	'Referer': 'http:<span class="comment">//www.cnbeta.com/articles'</span></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.abbeychenxi.net/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python网络爬虫[四]]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/06/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%5B%E5%9B%9B%5D/"/>
    <id>http://www.abbeychenxi.net/2014/09/06/Python网络爬虫[四]/</id>
    <published>2014-09-06T15:49:25.000Z</published>
    <updated>2014-10-25T14:35:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Openers">Openers</h2>
<p>当你获取一个URL你使用一个opener(一个urllib2.OpenerDirector的实例)。</p>
<p>正常情况下， 我们使用默认opener: 通过urlopen。</p>
<h2 id="Handles">Handles</h2>
<p>Openers使用处理器handlers，每个handlers知道如何通过特定协议打开URLs，或者如何处理URL打开时的各个方面。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> urllib2</div><div class="line"></div><div class="line"><span class="variable">password_mgr =</span> urllib2.HTTPPasswordMgrWithDefaultRealm()</div><div class="line"></div><div class="line"><span class="variable">top_level_url =</span> <span class="string">"http://example.com/foo/"</span></div><div class="line"></div><div class="line">password_mgr.add_password(None, top_level_url, 'why', '<span class="number">123</span>')</div><div class="line"></div><div class="line"><span class="variable">handler =</span> urllib2.HTTPBasicAuthHandler(password_mgr)</div><div class="line"></div><div class="line"><span class="variable">opener =</span> urllib2.build_opener(handler)</div><div class="line"></div><div class="line"><span class="variable">a_url =</span> 'http://www.baidu.com/'</div><div class="line"></div><div class="line">opener.open(a_url)</div><div class="line"></div><div class="line">urllib2.install_opener(open)</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.abbeychenxi.net/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python网络爬虫[三]]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/06/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%5B%E4%B8%89%5D/"/>
    <id>http://www.abbeychenxi.net/2014/09/06/Python网络爬虫[三]/</id>
    <published>2014-09-06T09:51:23.000Z</published>
    <updated>2014-10-25T14:35:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="HTTP异常处理">HTTP异常处理</h2>
<p>urlopen不能处理一个response时，产生urlError。</p>
<p>不过通常的Python APIs异常也会同时产生。</p>
<p>HTTPError是urlError的子类，通常在特定HTTP URLs中产生。</p>
<h1 id="URLError">URLError</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">req = urllib2.Request(<span class="string">'http://www.baidu.com'</span>)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	urllib2.urlopen(req)</div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">	<span class="keyword">print</span> e.ereason</div></pre></td></tr></table></figure>

<h1 id="HTTPError">HTTPError</h1>
<p>服务器上每一个HTTP应答对象response包含一个数字“状态码”。</p>
<p>有时状态码指出服务器无法完成请求。默认的处理器会为你处理一部分这种应答。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">req = urllib2.Request(<span class="string">'http://bbs.csdn.net/callmewhy'</span>)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	urllib2.urlopen(req)</div><div class="line">	</div><div class="line"><span class="keyword">except</span> urllib2.URLError, e:</div><div class="line">	<span class="keyword">print</span> e.code</div></pre></td></tr></table></figure>

<h1 id="Wrapping">Wrapping</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request, urlopen, URLError, HTTPError</div><div class="line"></div><div class="line">req = Request(<span class="string">'http://bbs.csdn.net/callmewhy'</span>)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	response = urlopen(req)</div><div class="line"></div><div class="line"><span class="keyword">except</span> URLError, e:</div><div class="line">	<span class="keyword">if</span> hasattr(e, <span class="string">'code'</span>):</div><div class="line">		<span class="keyword">print</span> <span class="string">'The server couldn\'t fulfill the request.'</span></div><div class="line">		</div><div class="line">		<span class="keyword">print</span> <span class="string">'Error code: '</span>, e.code</div><div class="line">	<span class="keyword">elif</span> has attr(e, <span class="string">'reason'</span>):</div><div class="line">		<span class="keyword">print</span> <span class="string">'We failed to reach a server.'</span></div><div class="line">		</div><div class="line">		<span class="keyword">print</span> <span class="string">'Reason:'</span>, e.reason</div><div class="line">		</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	<span class="keyword">print</span> <span class="string">'No exception was raised.'</span></div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.abbeychenxi.net/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python网络爬虫[二]]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/06/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%5B%E4%BA%8C%5D/"/>
    <id>http://www.abbeychenxi.net/2014/09/06/Python网络爬虫[二]/</id>
    <published>2014-09-06T05:40:00.000Z</published>
    <updated>2014-10-25T14:35:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="urllib2">urllib2</h2>
<p>urllib2组件来抓取网页。<br>urllib2是python的一个获取URLs的组件。<br>它以urlopen函数的形式提供了一个简单的接口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com/'</span>)</div><div class="line">html = response.<span class="keyword">read</span>()</div><div class="line"><span class="keyword">print</span> html</div></pre></td></tr></table></figure>

<p>urllib2用一个response对象来映射你提出的http请求。</p>
<p>在HTTP请求时：</p>
<h1 id="发送data表单数据">发送data表单数据</h1>
<p>发送一些数据到URL，在HTTP中，这个经常使用POST请求发送。<br>这个通常在你提交一个HTML表单时由你的浏览器来做。<br>并不是所有的POSTs都来源于表单，能够使用POST提交任意的数据到自己的程序。<br>一般的HTML表单，data需要编码成标准形式。然后做为data参数传到Request对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">url <span class="subst">=</span> <span class="string">'http://www.someserver.com/register.cgi'</span></div><div class="line"></div><div class="line">values <span class="subst">=</span> {<span class="string">'name'</span>: <span class="string">'WHY'</span>,</div><div class="line">		  <span class="string">'location'</span>: <span class="string">'SDU'</span>,</div><div class="line">		  <span class="string">'language'</span>: <span class="string">'Python'</span> }</div><div class="line"></div><div class="line"><span class="built_in">data</span> <span class="subst">=</span> urllib<span class="built_in">.</span>urlencode(values) <span class="comment">//编码工作</span></div><div class="line">req <span class="subst">=</span> urllib2<span class="built_in">.</span>Request(url, <span class="built_in">data</span>) <span class="comment">// 发送请求同时传data表单</span></div><div class="line">response <span class="subst">=</span> urllib2<span class="built_in">.</span>urlopen(req) <span class="comment">//接受反馈的信息</span></div><div class="line">the_page <span class="subst">=</span> response<span class="built_in">.</span>read() <span class="comment">//读取反馈的内容</span></div></pre></td></tr></table></figure>

<p>如果没有传送data参数，urllib2使用GET方式的请求。<br>GET和POST请求的不同之处是POST请求通常有“副作用”，<br>它们会由于某种途径改变系统状态。<br>Data同样可以通过在Get请求的URL本身上面编码来传送。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="import"><span class="keyword">import</span> urllib2</span></div><div class="line"><span class="import"><span class="keyword">import</span> urllib</span></div><div class="line"></div><div class="line"><span class="typedef"><span class="keyword">data</span> = <span class="container">{}</span></span></div><div class="line"></div><div class="line"><span class="typedef"><span class="keyword">data</span>['name'] = '<span class="type">WHY'</span></span></div><div class="line"><span class="typedef"><span class="keyword">data</span>['location'] = '<span class="type">SDU'</span></span></div><div class="line"><span class="typedef"><span class="keyword">data</span>['language'] = '<span class="type">Python'</span></span></div><div class="line"></div><div class="line"><span class="title">url_values</span> = urllib.urlencode(<span class="typedef"><span class="keyword">data</span>)</span></div><div class="line"><span class="title">print</span> url_value</div><div class="line"></div><div class="line"><span class="title">name</span> = <span class="type">Somebody</span>+<span class="type">Here</span>&language=<span class="type">Python</span>&location=<span class="type">Northampton</span></div><div class="line"><span class="title">url</span> = 'http://www.example.com/example.cgi'</div><div class="line"><span class="title">full_url</span> = url + '?' + url_values</div><div class="line"></div><div class="line"><span class="typedef"><span class="keyword">data</span> = urllib2.open<span class="container">(<span class="title">full_url</span>)</span></span></div></pre></td></tr></table></figure>

<p>这就实现了Data数据的Get传送。</p>
<h1 id="设置Headers到http请求">设置Headers到http请求</h1>
<p>有一些站点不喜欢被程序访问，或者发送不同版本的内容到不同的浏览器。<br>浏览器确认自己身份是通过User-Agent头，当你创建了一个请求对象，你可以给他一个包含头数据的字典。</p>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.abbeychenxi.net/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python网络爬虫[一]]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/04/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%5B%E4%B8%80%5D/"/>
    <id>http://www.abbeychenxi.net/2014/09/04/Python网络爬虫[一]/</id>
    <published>2014-09-04T15:39:08.000Z</published>
    <updated>2014-10-25T14:35:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="URI">URI</h2>
<p>URI通常由三部分组成：</p>
<ol>
<li>访问资源的命名机制；</li>
<li>存放资源的主机名</li>
<li>资源自身的名称，由路径表示</li>
</ol>
<p>URI定义:统一资源标识符<br>URL定义:统一资源定位符</p>
<p>爬虫最主要的处理对象就是URL，它根据URL地址取得所需要的文件内容，然后对它进行进一步的处理。</p>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.abbeychenxi.net/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[today]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/04/today/"/>
    <id>http://www.abbeychenxi.net/2014/09/04/today/</id>
    <published>2014-09-03T20:09:48.000Z</published>
    <updated>2014-10-25T14:36:11.000Z</updated>
    <content type="html"><![CDATA[<p>今天入学教育，正式成为了NJU的一名学生。<br>晚上成功搭建了自己的个人博客！<br>I’m so happy!<br>Thanks everyone!</p>
]]></content>
    
    
      <category term="NJU" scheme="http://www.abbeychenxi.net/tags/NJU/"/>
    
  </entry>
  
</feed>
