<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Abbey in Cradle Studio]]></title>
  <subtitle><![CDATA[年少轻狂 | 关注Spark、R]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.abbeychenxi.net/"/>
  <updated>2016-04-08T15:45:49.253Z</updated>
  <id>http://www.abbeychenxi.net/</id>
  
  <author>
    <name><![CDATA[Abbey]]></name>
    <email><![CDATA[Abbeychenx@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[台北 Day-1]]></title>
    <link href="http://www.abbeychenxi.net/2016/04/08/%E5%8F%B0%E5%8C%97-Day-1/"/>
    <id>http://www.abbeychenxi.net/2016/04/08/台北-Day-1/</id>
    <published>2016-04-08T15:33:22.000Z</published>
    <updated>2016-04-08T15:40:05.000Z</updated>
    <content type="html"><![CDATA[<p>下午5点的飞机从盐城飞往台北。飞机上，被空乘的弯弯腔调萌酥了，已被俘虏-。-</p>
<p>晚上11点的样子到了第一晚的酒店。<br>上个图。<br><img src="http://ww2.sinaimg.cn/large/b34f7e8bjw1f2ppzwpv7ej21kw16oas4.jpg" alt=""><br>😳<br>就酱，我写论文了~~~</p>
]]></content>
    
    
      <category term="Traveling" scheme="http://www.abbeychenxi.net/categories/Traveling/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[由一个STOP命令挖出Ambari如何下发任务]]></title>
    <link href="http://www.abbeychenxi.net/2015/12/16/%E7%94%B1%E4%B8%80%E4%B8%AASTOP%E5%91%BD%E4%BB%A4%E6%8C%96%E5%87%BAAmbari%E5%A6%82%E4%BD%95%E4%B8%8B%E5%8F%91%E4%BB%BB%E5%8A%A1/"/>
    <id>http://www.abbeychenxi.net/2015/12/16/由一个STOP命令挖出Ambari如何下发任务/</id>
    <published>2015-12-16T12:00:10.000Z</published>
    <updated>2015-12-16T12:00:13.000Z</updated>
    <content type="html"><![CDATA[<p>天龙系统部署MINIRDS失败，重试时，Ambari会对所有已经安装成功的组件下发一个STOP命令。对这个STOP，处女座的@风煜表示不能忍，so。。。开始啃Ambari源码之路。。。</p>
<p><img src="http://ww4.sinaimg.cn/large/b34f7e8bgw1ez1miuxo0vj217g0t87b1.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/b34f7e8bgw1ez1mjpt1bbj21600jewgu.jpg" alt=""></p>
<p>抓包发现重试时，前端向server发送了一个PUT请求<br><img src="http://ww4.sinaimg.cn/large/b34f7e8bgw1ez1mlve9r1j21j20i8afu.jpg" alt=""></p>
<p>ok，这个PUT请求到server端之后，server到底做了什么呢？？</p>
<p>如下图所示，一个API如何产生部署阶段-&gt;stage<br><img src="http://ww1.sinaimg.cn/large/b34f7e8bgw1ez1nl6urk5j20tq0psaf6.jpg" alt=""></p>
<p>在Ambari中什么是stage呢，以部署MINIRDS为例，需要部署GLOBALCONFIG，METADB，BAKDB，PERFDB…..等等等等。</p>
<p>这些任务如PERFDB,BAKDB必须依赖METADB，所以部署PERFDB时必须保证METADB部署完成，所以GLOBALCOONFIG、METADB为第一阶段，PERFDB，BAKDB为第二阶段。</p>
<p>总体来讲，stage的任务规划是按照DAG的方式来实现的。什么是DAG？</p>
<p><code>DAG：在图论中，如果一个有向图无法从任意顶点出发经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。
因为有向图中一个点经过两种路线到达另一个点未必形成环，因此有向无环图未必能转化成树，但任何有向树均为有向无环图。</code><br><img src="http://ww2.sinaimg.cn/large/b34f7e8bgw1ez1o25dy3jj20k00ekgmd.jpg" alt=""></p>
<p>如何实现DAG？</p>
<p>在Ambari server算法中，所有的service作为一个结点(即METADB、GLOBALCONFIG)，节点间的依赖关系为eage(边)，如PERFDB依赖METADB，所以有一条METADB指向PERFDB的边。</p>
<p>如何划分stage？</p>
<p>遍历所有节点，将入度(指向该节点的边的个数)为0的节点作为一个stage，并将这些节点从原来哈希表中删除。<br>循环直至，所有节点都划分完毕。</p>
<p>从数据库中的数据验证结果。。。。<br><img src="http://ww2.sinaimg.cn/large/b34f7e8bgw1ez1oc1mcawj213i0qox0p.jpg" alt=""></p>
<p>为什么会给安装好的组件下发STOP命令呢？</p>
<p>这是Ambari Controller的策略。在ambari server中，每个component都有一个状态机，当重试时，component状态为INSTALLED时，controller会向对应状态机执行STOP命令对应的HOST_SERVICE_COMPONENT_EVENT。</p>
]]></content>
    
    
      <category term="Ambari" scheme="http://www.abbeychenxi.net/categories/Ambari/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[folly-PicoSpinLock]]></title>
    <link href="http://www.abbeychenxi.net/2015/08/11/folly-PicoSpinLock/"/>
    <id>http://www.abbeychenxi.net/2015/08/11/folly-PicoSpinLock/</id>
    <published>2015-08-11T08:51:02.000Z</published>
    <updated>2015-09-10T03:26:40.000Z</updated>
    <content type="html"><![CDATA[<p>folly中实现的自旋锁</p>
<p>占一个比特的自旋锁实现，可以在16 32 64位integral 类型中使用。</p>
<p>当想要用一个很小的锁 并且 已经存在一个int值而且保证有一位没有使用的情况下，folly的spinLock非常有用。</p>
<p>在SpinLock的实现中，没有一个真正的构造器，因为这是个POD类型，可以将它封装进结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cinttypes&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;type_traits&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;pthread.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;folly/detail/Sleeper.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;folly/Portability.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> folly {</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> IntType, <span class="keyword">int</span> But = <span class="keyword">sizeof</span>(IntType) * <span class="number">8</span> - <span class="number">1</span>&gt;</div><div class="line"><span class="keyword">struct</span> PicoSpinLock {</div><div class="line">  <span class="comment">//内部处理unsigned类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::make_unsigned&lt;IntType&gt;::type UIntType;  </div><div class="line">  </div><div class="line">  <span class="keyword">static_assert</span>(std::is_integral&lt;IntType&gt;::value, <span class="string">"PicoSpinLock needs an integral type"</span>);</div><div class="line">  <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(IntType) == <span class="number">2</span> || <span class="keyword">sizeof</span>(IntType) == <span class="number">4</span> || <span class="keyword">sizeof</span>(IntType) == <span class="number">8</span>, <span class="string">"PicoSpinLock can't work on integers smaller than 2 bytes"</span>);</div><div class="line">  </div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> UIntType kLockBitMask_ = UintType(<span class="number">1</span>) &lt;&lt; Bit;</div><div class="line">  UIntType lock_;</div><div class="line">  </div><div class="line">  <span class="comment">//在使用PicoSpinLock这个类之前必须显式调用init方法,这保证了POD类型</span></div><div class="line">  <span class="keyword">void</span> init(IntType initialValue = <span class="number">0</span>) {</div><div class="line">    CHECK(!(initialValue & kLockBitMask_));</div><div class="line">    lock_ = initialValue;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">//返回SpinLock所使用的整型值，除去lock占用的bit位</span></div><div class="line">  <span class="comment">//这是个线程安全方法</span></div><div class="line">  IntType getData() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;IntType&gt;(lock_ & ~kLockBitMask_);</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">//设置其他bit位的值</span></div><div class="line">  <span class="comment">//该方法必须持有锁</span></div><div class="line">  <span class="keyword">void</span> setData(IntType w) {</div><div class="line">    CHECK(!(w & kLockBitMask_));</div><div class="line">    lock_ = (lock_ & kLockBitMask_) | w;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">//尝试持有锁的方法</span></div><div class="line">  <span class="keyword">bool</span> try_lock() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">bool</span> ret = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    ret = __atomic_fetch_or(&lock_, <span class="number">1</span> &lt;&lt; Bit, __ATOMIC_SEQ_CST);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">//直到持有锁，否则一直阻塞</span></div><div class="line">  <span class="keyword">void</span> lock() <span class="keyword">const</span> {</div><div class="line">    detail::Sleeper sleeper;</div><div class="line">    <span class="keyword">while</span> (!try_lock()) {</div><div class="line">      sleeper.wait();</div><div class="line">    }</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">//释放锁</span></div><div class="line">  <span class="keyword">void</span> unlock() <span class="keyword">const</span> {</div><div class="line">    __atomic_fetch_and(&lock_, ~(<span class="number">1</span> &lt;&lt; Bit), __ATOMIC_SEQ_CST);</div><div class="line">  }</div><div class="line">};</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="folly" scheme="http://www.abbeychenxi.net/tags/folly/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[folly-SyncPtr]]></title>
    <link href="http://www.abbeychenxi.net/2015/08/11/folly-SyncPtr/"/>
    <id>http://www.abbeychenxi.net/2015/08/11/folly-SyncPtr/</id>
    <published>2015-08-11T08:09:47.000Z</published>
    <updated>2015-08-11T08:56:24.000Z</updated>
    <content type="html"><![CDATA[<p>PackedSyncPtr不是一个智能指针，Lock提升到用户层面。资源的释放也由用户控制。除非显式的调用lock(), unlock()，不会获取以及释放锁。</p>
<p>通过set()接口改变原始指针的值，但是当多线程环境下，调用该方法必须持有锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> PackedSyncPtr {</div><div class="line"><span class="comment">//允许当T为void的时候使用该类， 当对PackedSyncPtr&lt;void&gt;使用*或者[]操作符的时候，将产生编译错误</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::add_lvalue_reference&lt;T&gt;::type reference;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">//初始化动作</span></div><div class="line">    <span class="keyword">void</span> init(T* initialPtr = <span class="number">0</span>, uint16_t initialExtra = <span class="number">0</span>) {</div><div class="line">        <span class="keyword">auto</span> intPtr = <span class="keyword">reinterpret_cast</span>&lt;uintptr_t&gt;(initialPtr);</div><div class="line">        CHECK(!(intPtr &gt;&gt; <span class="number">48</span>));</div><div class="line">        data_.init(inntPtr);</div><div class="line">        setExtra(initialExtra);</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="comment">//设置一个新指针，多线程环境下应当持有锁，或者不与其他线程共享PackedSyncPtr</span></div><div class="line">    <span class="keyword">void</span> <span class="built_in">set</span>(T* t) {</div><div class="line">        <span class="keyword">auto</span> intPtr = <span class="keyword">reinterpret_cast</span>&lt;uintptr_t&gt;(t);</div><div class="line">        <span class="keyword">auto</span> shiftedExtra = uintptr_t(extra()) &lt;&lt; <span class="number">48</span>;</div><div class="line">        CHECK(!(intPtr &gt;&gt; <span class="number">48</span>));</div><div class="line">        data_.setData(intPtr | shiftedExtra);</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="comment">//获取指针</span></div><div class="line"><span class="comment">//该方法不需要持有锁</span></div><div class="line">    T* get() <span class="keyword">const</span> {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(data_.getData() & (-<span class="number">1u</span>ll &gt;&gt; <span class="number">16</span>));</div><div class="line">    }</div><div class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> { <span class="keyword">return</span> get(); }</div><div class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> { <span class="keyword">return</span> *get(); }</div><div class="line">    reference <span class="keyword">operator</span>[](std::ptrdiff_t i) <span class="keyword">const</span> { <span class="keyword">return</span> get()[i]; }</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> lock() <span class="keyword">const</span> { data_.lock(); }</div><div class="line">    <span class="keyword">void</span> unlock() <span class="keyword">const</span> { data_.unlock(); }</div><div class="line">    <span class="keyword">bool</span> try_lock() <span class="keyword">const</span> { <span class="keyword">return</span> data_.try_lock(); }</div><div class="line">    </div><div class="line"><span class="comment">//储存在指针内未使用的bytes的入口</span></div><div class="line">    uint_t extra() <span class="keyword">const</span> {</div><div class="line">        <span class="keyword">return</span> data_.getData() &gt;&gt; <span class="number">48</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> setExtra(uint16_t extra) {</div><div class="line">        CHECK(!(extra & <span class="number">0x8000</span>));</div><div class="line">        <span class="keyword">auto</span> ptr = data_.getData() & (-<span class="number">1u</span>ll &gt;&gt; <span class="number">16</span>);</div><div class="line">        data_.setData((uintptr_t(extra) &lt;&lt; <span class="number">48</span>) | ptr);</div><div class="line">    }</div><div class="line">    </div><div class="line">    PicoSpinLcok&lt;uintptr_t&gt; data_;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>高度专业化的数据结构组成的一个指针,1比特自旋锁,和15位内置类型,都储存在一个64位word中。</p>
<p>主要对自旋锁的封装<br>folly组件中有smallLock是对spinLock的实现。</p>
]]></content>
    
    
      <category term="folly" scheme="http://www.abbeychenxi.net/tags/folly/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大规模批处理系统]]></title>
    <link href="http://www.abbeychenxi.net/2015/06/16/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.abbeychenxi.net/2015/06/16/大规模批处理系统/</id>
    <published>2015-06-16T15:01:27.000Z</published>
    <updated>2015-06-16T15:27:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="背景:">背景:</h1>
<p>Google发表了MapReduce计算范型及其框架的论文。MapReduce和并行数据库系统(MPP)各有优劣并且两者有一定的互补和学习。与传统MPP架构相比，MapReduce更适合非结构化数据的ETL处理类操作，并且可扩展性和容错性占优，但是单机处理效率较低。<br>DAG计算模型是MapReduce计算机制的一种扩展。MapReduce对于子任务之间复杂的交互和依赖关系缺乏表达能力，DAG计算模型可以表达复杂的并发任务之间的依赖关系。<br>Spark本质上是DAG批处理系统，其最能发挥特长的领域是迭代式机器学习。</p>
<h1 id="MapReduce计算模型与架构">MapReduce计算模型与架构</h1>
<h2 id="计算模型">计算模型</h2>
<p>MapReduce计算任务的输入是Key/Value数据对，输出也以Key/Value数据对方式表示。开发者要根据业务逻辑实现Map和Reduce两个接口函数内的具体操作内容，即可完成大规模数据的并行批处理任务。</p>
<p>实例一:单词统计  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">map(<span class="type">String</span> key, <span class="type">String</span> value):</div><div class="line">    //key: 文档名</div><div class="line">    //value: 文档内容</div><div class="line">    <span class="keyword">for</span> each word <span class="keyword">in</span> value:</div><div class="line">        <span class="type">Emit</span> <span class="type">Intermedia</span>(w, <span class="string">"1"</span>);</div><div class="line"></div><div class="line">reduce(<span class="type">String</span> key, <span class="type">Iterator</span> values):</div><div class="line">    //key: 单词</div><div class="line">    //value: 出现次数列表</div><div class="line">    <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> values:</div><div class="line">        <span class="literal">result</span> += <span class="type">ParseInt</span>(v);//累加values值</div><div class="line">    <span class="type">Emit</span>(<span class="type">AsString</span>(<span class="literal">result</span>));</div></pre></td></tr></table></figure>

<p>实例二: 链表反转</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">map(<span class="type">String</span> source_url, <span class="type">Iterator</span> outlinks):</div><div class="line">    //key: 网页url</div><div class="line">    //value: 出链列表</div><div class="line">    <span class="keyword">for</span> each outlink o <span class="keyword">in</span> outlinks:</div><div class="line">        <span class="type">Emit</span> <span class="type">Intermedia</span>(o, source_url)</div><div class="line"></div><div class="line">reduce(<span class="type">String</span> target_url, <span class="type">Iterator</span> source_urls):</div><div class="line">    //key: target网页url</div><div class="line">    //values: source网页url</div><div class="line">    list <span class="literal">result</span> = [];</div><div class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> source_urls:</div><div class="line">        <span class="type">Result</span>.append(v);</div><div class="line">    <span class="type">Emit</span>(<span class="type">AsString</span>(<span class="literal">result</span>));</div></pre></td></tr></table></figure>

<p>实例三: 页面点击统计</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">map(<span class="type">String</span> tuple_id, <span class="type">String</span> <span class="keyword">tuple</span>):</div><div class="line">    <span class="type">Emit</span> <span class="type">Intermedia</span>(url, <span class="string">"1"</span>);</div><div class="line"></div><div class="line">reduce(<span class="type">String</span> url, <span class="type">Iterator</span> list_tuples):</div><div class="line">    <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> list_tuples:</div><div class="line">        <span class="literal">result</span> += <span class="type">ParseInt</span>(v);</div><div class="line">    <span class="type">Emit</span>(<span class="type">AsString</span>(<span class="literal">result</span>));</div></pre></td></tr></table></figure>

<h2 id="系统架构">系统架构</h2>
<p><img src="http://ww4.sinaimg.cn/mw690/b34f7e8bgw1et6a2h93grj207505gq2v.jpg" alt="MapReduce计算框架架构"></p>
<p>处理流程:  </p>
<ol>
<li>MapReduce框架将应用的输入数据切分成M个模块，典型的数据块大小为64MB，然后可以启动位于集群中不同机器上若干程序。</li>
<li>全局唯一的主控Master以及若干个Worker，Master负责为Worker分配具体的Map任务或Reduce任务并做一些全局管理。</li>
<li>Map任务的Worker读取对应的数据块内容，从数据块中解析一个个Key/Value记录数据并将其传给用户自定义的Map函数，Map函数输出的中间结果Key/Value数据在内存中缓存</li>
<li>缓存的Map函数产生的中间结果周期性写入磁盘，每个Map函数中间结果在写入磁盘前被分割函数切割成R份，R是Reduce个数。一般用key对R进行哈希取模。Map函数完成对应数据块处理后将R个临时文件位置通知Master，Master再转交给Reduce任务的Worker</li>
<li>Reduce任务Worker接到通知时，通过RPC远程调用将Map产生的M份数据文件pull到本地。(只有所有Map函数完成，Reduce才能执行)。Reduce任务根据中间数据的Key对记录进行排序，相同key的记录聚合在一起</li>
<li>Reduce任务Worker遍历有序数据，将同一个Key及其对应的多个Value传递给用户定义的Reduce函数，reduce函数执行业务逻辑后将结果追加到Reduce对应的结果文件末尾</li>
<li>所有Map、Reduce任务完成，Master唤醒用户应用程序</li>
</ol>
<p>为了优化执行效率，MapReduce计算框架在Map阶段还可以执行Combiner操作。</p>
<p>hadoop的MapReduce运行机制基本与google的类似。<br><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1et6akb0hakj20fg08q3zb.jpg" alt="hadoop的MapReduce运行机制"><br>不同的是，hadoop采用https协议来进行数据传输，并采用归并排序对中间结果进行排序。<br>Google的MapReduce框架支持细粒度的容错机制。Master周期性Ping各个Worker，如果Worker没有响应，则认为其已经发生故障。<br>如果Master故障则单点失效，重新提交任务。</p>
<h2 id="MapReduce不足">MapReduce不足</h2>
<ol>
<li>无高层抽象数据操作语言</li>
<li>数据无Schema及索引</li>
<li>单节点效率低下</li>
<li>任务流描述方法单一</li>
</ol>
<p>优势:  </p>
<ol>
<li>数据吞吐量高</li>
<li>支持海量数据处理的大规模并行处理</li>
<li>细粒度容错<br>但是不适合对时效性高的应用场景，比如交互查询或流处理，也不适合迭代计算类的机器学习及数据挖掘类应用。</li>
</ol>
<p>由于:  </p>
<ol>
<li>启动时间长</li>
<li>多处读写磁盘及网络传输</li>
</ol>
<h1 id="DAG计算模型">DAG计算模型</h1>
<p>有向无环图的简称。在大数据处理领域,DAG计算模型是将计算任务在内部分解成若干子任务，这些子任务之间由逻辑关系或运行先后顺序等因素被构建成有向无环图结构。</p>
<h2 id="DAG计算系统三层结构">DAG计算系统三层结构</h2>
<ul>
<li>最上层是应用表达层，通过一定手段将计算任务分解成若干子任务形成的DAG结构</li>
<li>最下层是物理机集群，由大量物理机器搭建的分布式计算环境</li>
<li>中间层是DAG执行引擎层，将上层以特殊方式表达的DAG计算任务通过转换和映射，将其部署到下层的物理机集群中运行</li>
</ul>
<h2 id="Dryad">Dryad</h2>
<p>微软DAG计算系统，dryad在实现时以共享内存、TCP连接以及临时文件的方式进行数据传输</p>
<h3 id="Dryad整体架构">Dryad整体架构</h3>
<p><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1et6b3zh4plj20dw07xq49.jpg" alt="Dryad整体架构"></p>
<p>job manager负责将逻辑形式存在的DAG描述映射到物理机。NS负责维护集群中当前可以的机器资源。Daemon守护进程作为JM在计算节点上的代理，具体负责子任务的执行和监控。</p>
<h2 id="FlumeJava和Tez">FlumeJava和Tez</h2>
<ul>
<li>FlumeJava构建了java库，本质上是在MapReduce基础上的DAG计算系统，图中每个节点可以看作单个MapReduce子任务。</li>
<li>Tez使用Map任务或者Reduce任务作为DAG的图节点，图节点的有向边是数据传输通道。Tez消除Map阶段中间文件输出到磁盘过程以及引入Reduce-Reduce结构改进措施提升执行效率</li>
</ul>
]]></content>
    
    
      <category term="大数据" scheme="http://www.abbeychenxi.net/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TF-IDF模型]]></title>
    <link href="http://www.abbeychenxi.net/2015/06/16/TF-IDF%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.abbeychenxi.net/2015/06/16/TF-IDF模型/</id>
    <published>2015-06-16T09:58:48.000Z</published>
    <updated>2015-06-16T10:00:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="词频因此(tf)">词频因此(tf)</h2>
<p>Tf计算因子代表了词频，即一个单词在文档中出现的次数。</p>
<p>变体1: $W<em>{tf} = 1 + log(Tf)$<br>变体2: $W</em>{tf} = a + (1-a)\times{Tf\over Max(Tf)}$<br>(a=0.4)<br>同一个文档内单词之间的相对重要性。</p>
<h2 id="逆文档频率因子(IDF)">逆文档频率因子(IDF)</h2>
<p>表示文档集合范围的一种全局因子。给定一个文档集合，那么每个单词的IDF值就唯一确定，跟具体的文档无关。所以IDF考虑的不是文档本身的特性，而是特征单词之间的相对重要性。<br>$IDF_k = log{N \over n_k}$<br>N: 文档数目<br>$n_k$: 文档频率  </p>
<h2 id="TF-IDF框架">TF-IDF框架</h2>
<p>$Weight_{word} = TF \times IDF$</p>
]]></content>
    
    
      <category term="搜索引擎" scheme="http://www.abbeychenxi.net/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sed awk学习]]></title>
    <link href="http://www.abbeychenxi.net/2015/06/07/sed-awk%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.abbeychenxi.net/2015/06/07/sed-awk学习/</id>
    <published>2015-06-07T05:12:44.000Z</published>
    <updated>2015-06-07T05:48:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sed">sed</h1>
<p>sream editor</p>
<p>将文件/etc/passwd中，/bin/bash指定的登录shell全部替换成/usr/local/bin/bash</p>
<p>d(删除) / p(数据输出) / y(替换1个字符) / w(文件输出) /n (数据输入)</p>
<h2 id="s命令(字符串替换)">s命令(字符串替换)</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed <span class="operator">-e</span> <span class="string">'s/原字符串/[替换后的字符串]/[标志]'</span> 输入文件</div><div class="line">sed <span class="operator">-e</span> <span class="string">'s/aaa//g'</span> input.txt</div><div class="line">sed <span class="operator">-e</span> <span class="string">'s/\//R/'</span> input.txt</div><div class="line">sed <span class="operator">-e</span> <span class="string">'s!/usr/local!/user!g'</span> input.txt</div></pre></td></tr></table></figure>

<p>替换字符串中出现&amp; 表示和查找字符串一样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed <span class="operator">-e</span> <span class="string">'s/aaa/+&+/g'</span> input.txt</div><div class="line">可以和正则表达式结合:</div><div class="line">sed <span class="operator">-e</span> <span class="string">'s/.*/output: &/g'</span> input.txt</div></pre></td></tr></table></figure>

<h2 id="y命令(替换一个字符)">y命令(替换一个字符)</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e <span class="string">'y/替换前/替换后/'</span> 输入文件</div><div class="line">同时替换多个字符a=&gt;x, b=&gt;y, c=&gt;z的替换</div><div class="line">sed -e <span class="string">'y/abc/xyz/'</span> input.txt</div></pre></td></tr></table></figure>

<h2 id="d命令(删除)">d命令(删除)</h2>
<p>d是删除指定行，并将剩余行进行输出的命令<br><code>sed -e &#39;1,2d&#39; input.txt</code></p>
<h3 id="地址">地址</h3>
<p>只对特定行进行处理时。如果省略地址对所有行都会处理。start,end。 最后一行用$表示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="operator">-e</span> <span class="string">'1,3p'</span> input.txt</div><div class="line">sed -n <span class="operator">-e</span> <span class="string">'2,$p'</span> input.txt</div></pre></td></tr></table></figure>

<p>指定地址支持正则表达式</p>
<table>
<thead>
<tr>
<th>地址例</th>
<th>表示的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>(未指定的行)</td>
<td>所有数据</td>
</tr>
<tr>
<td>3</td>
<td>第三行</td>
</tr>
<tr>
<td>20,$</td>
<td>从20行开始到最后一行</td>
</tr>
<tr>
<td>10, 5</td>
<td>第10行(第2个数字比第1个数字小的情况)</td>
</tr>
<tr>
<td>/^[0-9]/</td>
<td>所有以数字开头的行</td>
</tr>
<tr>
<td>15, /z$/</td>
<td>从第15行开始到以z结尾的行</td>
</tr>
<tr>
<td>5, 10!</td>
<td>从第5行开始到第10行以外的行</td>
</tr>
</tbody>
</table>
<p><code>sed -n -e &#39;/^aaa/,/ddd$/p&#39; input.txt</code></p>
<h3 id="指定多个命令">指定多个命令</h3>
<p>命令之间以;分隔<br><code>sed -e &#39;2d;s/aaa/eee/g&#39; input.txt</code></p>
<h2 id="脚本文件的读取和执行">脚本文件的读取和执行</h2>
<p><code>sed -f 脚本文件 输入文件</code><br>可以指定多个脚本文件，也可以同时使用-e 和 -f 选项<br>在脚本文件中一行记述一个处理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,3s/<span class="keyword">aaa</span>/eee/g</div><div class="line"><span class="number">3d</span></div></pre></td></tr></table></figure>

<p><code>sed -f xxx.sed input.txt</code></p>
<h2 id="命令的组合">命令的组合</h2>
<p>‘{…}’对命令进行组合</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">3</span>{</div><div class="line">    <span class="regexp">s/aaa/eee/g</span></div><div class="line">    <span class="keyword">y</span>/abc/xyz/</div><div class="line">    p</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="标签/分支处理/循环处理">标签/分支处理/循环处理</h3>
<p>可以在脚本中设置标签进行循环处理，还可以将是否执行了s命令的替换处理作为判断条件对处理进行分支</p>
<table>
<thead>
<tr>
<th>指定方法</th>
<th>所表示的内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>:label名</td>
<td>指定标签,label名在脚本中是唯一的</td>
</tr>
<tr>
<td>b label名</td>
<td>无条件跳转到label名指定的命令进行执行</td>
</tr>
<tr>
<td>条件b label名</td>
<td>输入行满足条件时，跳转到label名指定的命令进行执行如果指定”/模式/b 标签”，输入行和模式匹配时，跳转到label名指定的命令进行执行</td>
</tr>
<tr>
<td>条件 !b label名</td>
<td>输入行不满足条件时，跳转到label名指定的命令进行执行 如果指定”/模式/!b标签”,输入行和模式不匹配时，跳转到label名指定的命令进行执行</td>
</tr>
<tr>
<td>t label名</td>
<td>读入输入行执行命令，只有在使用s命令替换成功时才会跳转到label名指定的命令进行执行</td>
</tr>
<tr>
<td>T label名</td>
<td>读入输入行执行命令，在使用s命令替换不成功时才会跳转到label名指定的命令进行执行</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">: 标签</div><div class="line">命令<span class="number">1</span></div><div class="line">命令<span class="number">2</span></div><div class="line"><span class="regexp">/模式/</span>b 标签</div><div class="line">命令<span class="number">3</span></div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">loop</span></div><div class="line">N</div><div class="line">$!b <span class="keyword">loop</span></div><div class="line">s/\n<span class="comment">//g</span></div></pre></td></tr></table></figure>

<h1 id="awk">awk</h1>
<p>awk会事先把输入的数据根据字段单位进行分割。<br>awk的pattern和动作action<br>模式1 {动作1}<br>模式2 {动作2}<br>…<br>模式n {动作n}</p>
<p><code>awk &#39;脚本&#39; inputfile</code></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">awk</span> <span class="string">'length&gt;30'</span> inputfile <span class="comment">#长度超过半角30个字符的行</span></div><div class="line">awk <span class="string">'NF &gt;= 5 && NF &lt;= 10'</span> inputfile <span class="comment">#字段数在5个以上10以下的行</span></div><div class="line">awk <span class="string">'NR &lt;= 5'</span> inputfile <span class="comment">#只表示最开始的5行</span></div><div class="line">awk <span class="string">'NR%2 == 0'</span> inputfile <span class="comment">#只表示偶数行</span></div><div class="line">awk <span class="string">'<span class="variable">$1</span> &lt; 100'</span> inputfile <span class="comment">#表示第一个字段的值比100小的行</span></div><div class="line">awk <span class="string">'/问题|答案/'</span> inputfile <span class="comment">#包含"问题"或者"答案"的行</span></div><div class="line">awk <span class="string">'/^#/'</span> inputfile <span class="comment">#以"#"开头的行</span></div></pre></td></tr></table></figure>

<p>内置函数length<br>$N(第N个字段)<br>NF(字段数)<br>NR(行号)</p>
<h2 id="AWK可以使用的模式">AWK可以使用的模式</h2>
<ul>
<li>空模式: 如果省略模式,所有的行都会匹配</li>
<li>正则表达式: 和sed一样</li>
<li>比较表达式和逻辑表达式: 比较运算是关于大小关系,是否匹配等的运算<code>$1 &lt; 100 &amp;&amp; $2 == &quot;ABC&quot;</code></li>
<li>BEGIN和END</li>
<li>模式范围 <code>pattern1, pattern2</code> <code>/^begin$/,/^end$/</code> <code>awk &#39;/^begin$/, /^end$/&#39; inputfile</code></li>
</ul>
<p>删除空白行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk '<span class="property">length</span> != <span class="number">0</span>' inputfile</div><div class="line">awk 'NF != <span class="number">0</span>' inputfile</div><div class="line">awk '<span class="keyword">before</span> != $<span class="number">0</span> { print; <span class="keyword">before</span> = $<span class="number">0</span> }' inputfile</div><div class="line">awk 'NF != <span class="number">0</span> || bf != <span class="number">0</span> { print; bf=NF }' inputfile</div><div class="line">awk '{ <span class="property">id</span>[$<span class="number">1</span>] = <span class="property">id</span>[$<span class="number">1</span>] <span class="string">" "</span> NR } END { <span class="keyword">for</span> (elm <span class="keyword">in</span> <span class="property">id</span>) print elm <span class="string">" "</span> <span class="property">id</span>[elm]}' inputfile</div></pre></td></tr></table></figure>

<h2 id="AWK脚本">AWK脚本</h2>
<p><code>awk -f scriptfile inputfile</code></p>
<h3 id="动作">动作</h3>
<ul>
<li>在动作中可以使用的语句</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">表达式：常量，变量，代入，函数调用</div><div class="line"><span class="keyword">print</span> 表达式的排列</div><div class="line"><span class="keyword">printf</span> 格式，表达式的排列</div><div class="line"><span class="keyword">if</span> (表达式) 语句</div><div class="line"><span class="keyword">if</span> (表达式: 语句 <span class="keyword">else</span> 语句)</div><div class="line"><span class="keyword">while</span>(表达式) 语句</div><div class="line"><span class="keyword">do</span> 语句 <span class="keyword">while</span> (表达式)</div><div class="line"><span class="keyword">for</span> (表达式; 表达式; 表达式) 语句</div><div class="line"><span class="keyword">for</span> (变量 in 数组) 语句</div><div class="line"><span class="keyword">continue</span></div><div class="line"><span class="keyword">break</span></div><div class="line"><span class="keyword">next</span></div><div class="line"><span class="keyword">exit</span></div><div class="line"><span class="keyword">exit</span> 表达式</div><div class="line">{ 表达式的排列 }</div></pre></td></tr></table></figure>

<h3 id="特殊变量">特殊变量</h3>
<ul>
<li>$1, $2,…,$n 和 $0<br>$0 输入行全体</li>
<li>ARGC， ARGV<br>ARGC 命令行参数的个数<br>ARGV 命令行参数的数组</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN {</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; ARGC; ++i)</div><div class="line">    <span class="built_in">print</span> ARGV[i]</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>FILENAME 保存当前输入文件的文件名</li>
<li>FNR 当前文件的行号</li>
<li>FS 输入字段分隔符的变量</li>
<li>NF 当前行的字段数</li>
<li>NR 读入的行数</li>
<li>OFS 输出字段分隔符的变量</li>
<li>ORS 输出行的分隔符变量</li>
<li><p>RS 输入行的分隔符变量</p>
</li>
<li><p>数组<br>awk数组是关联数组 下标不仅可以是数字还可以是字符串</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator">a</span>[n] = <span class="number">10</span></div><div class="line">b[<span class="string">"印度"</span>] = <span class="string">"India"</span></div><div class="line">c[x, y] 多元数组</div><div class="line"><span class="built_in">delete</span> <span class="operator">a</span>[n]</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="Linux" scheme="http://www.abbeychenxi.net/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络通用爬虫]]></title>
    <link href="http://www.abbeychenxi.net/2015/05/05/%E7%BD%91%E7%BB%9C%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB/"/>
    <id>http://www.abbeychenxi.net/2015/05/05/网络通用爬虫/</id>
    <published>2015-05-05T03:01:28.000Z</published>
    <updated>2015-05-05T03:03:12.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>从互联网页面中精心选择一部分网页，以这些网页的链接地址作为种子URL</li>
<li>将这些种子URL放入待抓取队列</li>
<li>爬虫从待抓取URL队列依次提取，并通过DNS解析，将链接地址转换为网站服务器对应IP地址</li>
<li>网页下载器负责将页面内容下载</li>
<li>下载到本地的网页，一方面将其存储到页面库中，等待建立索引；另一方面将下载网页的URL放入已抓取URL队列中，避免重复爬取</li>
</ol>
<h2 id="爬虫质量评估">爬虫质量评估</h2>
<p>抓取网页覆盖率、抓取网页时新性、抓取网页重要性</p>
<h2 id="抓取策略">抓取策略</h2>
<ol>
<li>宽度优先遍历策略</li>
<li>非完全PageRank策略</li>
<li>OCIP策略</li>
<li>大站优先策略</li>
</ol>
<h3 id="宽度优先遍历策略">宽度优先遍历策略</h3>
<p>将URL直接添加到待下载队列</p>
<h3 id="非完全PageRank策略">非完全PageRank策略</h3>
<p>对于已经下载的网页，加上待抓取URL队列的URL一起、形成网页集合，在此集合内进行PageRank计算。</p>
<h3 id="OCIP策略">OCIP策略</h3>
<p>在线页面重要性计算: 每个互联网页面给予一定的cash，每当下载了某个页面p，p将自己拥有的cash平均分配到页面包含的链接中，将自己的cash清空<br>效果略优于宽度优先遍历策略</p>
<h3 id="大站优先策略">大站优先策略</h3>
<p>以网站为单位来衡量网页重要性，对于待抓取URL队列中的网页，根据所属网站归类，如果哪个网站等待下载的页面最多，则优先下载这些链接。</p>
<h2 id="网页更新策略">网页更新策略</h2>
<p>常用策略: 历史参考策略、用户体验策略、聚类抽样策略</p>
<h3 id="历史参考策略">历史参考策略</h3>
<p>过去频繁更新的网站，将来也会频繁更新<br>利用泊松过程来建模，根据变化情况，利用模型预测将来何时内容会再次发生变化</p>
<h3 id="用户体验策略">用户体验策略</h3>
<p>保存网页的多个历史版本，并根据过去每次内容变化对搜索质量的影响，得出一个平均值，以此作为判断爬虫重抓该网页时机的参考依据，对于影响越厉害的网页，则越优先调度重新抓取</p>
<h3 id="聚类抽样策略">聚类抽样策略</h3>
<p>网页具有一些属性，根据属性可以预测其更新周期，具有相似属性的网页，其更新周期也是类似的。<br>根据这些属性将网页归类，同一类别内的网页拥有相同的更新周期。<br>网页更新周期的属性特征划分为两大类: 静态特征和动态特征<br>静态特征: 页面内容、图片数量、页面大小、链接深度、PageRank<br>动态特征: 体现静态特征随着时间的变化，如图片数量的变化情况、入链出链的情况。</p>
<h2 id="暗网抓取">暗网抓取</h2>
<h3 id="查询组合">查询组合</h3>
<p>对于某个固定的查询模板，如果给模板内每个属性都赋值，形成不同的查询组合，提交给垂直搜索引擎，观察所有返回页面的内容，如果相互之间内容差异较大，则这个查询模板就是富含信息查询模板。</p>
<p>ISIT查询模板技术: 首先从一维模板开始，对一维查询模板逐个考察，看其是否富含信息查询模板，如果是的话，则将这个一维模板扩展到二维，再次依次考察对应的二维模板，如此类推，逐步增加维数，直到再也无法找到富含信息查询模板为止。</p>
<p>Google的ISIT技术与经典的Apriori规则挖掘算法类似。</p>
<h2 id="分布式爬虫">分布式爬虫</h2>
<p>大型分布式爬虫3个层级: 分布式数据中心、分布式抓取服务器及分布式爬虫程序。</p>
<h3 id="主从式分布爬虫">主从式分布爬虫</h3>
<p>一台服务器专门负责提供URL的分发，将不同的URL分配给不同的抓取服务器。 维度URL分发的服务器成为瓶颈</p>
<h3 id="对等式分布爬虫">对等式分布爬虫</h3>
<p>对URL的主域名进行哈希计算，之后取模，当前服务器与取得URL哈希后的值匹配，则进行抓取任务，否则将该URL发送给对应的服务器</p>
<h3 id="问题:_某台服务器宕机_一致性哈希">问题: 某台服务器宕机  一致性哈希</h3>
<p>将网站主域名进行哈希，映射为一个范围在0到$2^{32}$之间的某个值，大量的网站主域名会被均匀地哈希到这个数值区间。将哈希值范围首尾相接，形成有序的环形序列。<br>例子:<br>2号服务器将URL发送给3号服务器，3号宕机，2号将得不到响应，则将URL发送给3号的下一个节点4号服务器。</p>
]]></content>
    
    
      <category term="搜索引擎" scheme="http://www.abbeychenxi.net/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络编程]]></title>
    <link href="http://www.abbeychenxi.net/2015/04/29/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.abbeychenxi.net/2015/04/29/网络编程/</id>
    <published>2015-04-29T03:03:26.000Z</published>
    <updated>2015-04-29T05:10:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="客户端服务器编程模型">客户端服务器编程模型</h1>
<p>客户端服务器模型中的基本操作是事务。一个客户端-服务器事务由四步组成:</p>
<ol>
<li>客户端需要服务，就向服务器发送请求，发起一个事务。</li>
<li>服务器收到请求，解释它，以适当的方式操作它的资源。</li>
<li>服务器给客户端发送一个响应，并等待下一个请求。</li>
<li>客户端收到响应并处理它</li>
</ol>
<p><img src="http://www.processon.com/view/link/55404f30e4b07e81dd4f2319" alt="image"></p>
<h1 id="网络">网络</h1>
<p>客户端在主机A上与LAN1相连，服务器在主机B上与LAN2相连。A发送数据到B的过程:</p>
<ol>
<li>A进行一个系统调用，从客户端的虚拟地址拷贝数据到内核缓冲区</li>
<li>主机A上的协议软件通过在数据头附加网络包(packge)和LAN1的帧头(frame)创建一个LAN1的帧。互联网络包头通过寻址到主机B。LAN帧头寻址到路由器。然后传送帧到适配器</li>
<li>LAN1适配器拷贝帧到网络上</li>
<li>帧到达路由器时，路由器的LAN1适配器从电缆上读取它，并传送到协议软件</li>
<li>路由器从互联网络包头提取出目的互联网络地址，并作索引。剥落LAN1的帧头加上LAN2的帧头</li>
<li>路由器的LAN2适配器拷贝该帧到网络</li>
<li>帧到达主机B，适配器从电缆读到帧，并传送到协议软件</li>
<li>主机B剥落包头和帧头。进行读取数据的系统调用，协议软件最终得到数据拷贝到服务器的虚拟地址空间。</li>
</ol>
]]></content>
    
    
      <category term="networking program" scheme="http://www.abbeychenxi.net/tags/networking-program/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Supervisord 一个简单方便的守护进程]]></title>
    <link href="http://www.abbeychenxi.net/2014/12/23/Supervisord-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%96%B9%E4%BE%BF%E7%9A%84%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.abbeychenxi.net/2014/12/23/Supervisord-一个简单方便的守护进程/</id>
    <published>2014-12-22T16:08:12.000Z</published>
    <updated>2015-05-05T03:42:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="生成配置文件">生成配置文件</h1>
<p>echo_supervisord_conf &gt; /etc/supervisord.conf</p>
<h1 id="配置">配置</h1>
<p>[program: my_app]<br>command = python /path/to/your/app.py 启动项目的命令<br>startsecs = 0<br>stopwaitsecs = 0<br>autostart = true<br>autorestart = true</p>
<h1 id="启动">启动</h1>
<ol>
<li>以配置文件启动 supervisord -c /etc/supervisord.conf</li>
<li>supervisord 默认启动是以/etc下的supervisord.conf启动</li>
</ol>
<h1 id="web界面">web界面</h1>
<ol>
<li>在配置文件中<br>[inet_http_server]<br>port = 0.0.0.0:9001<br>username = user<br>password = 123<br>访问localhost:9001就可以访问supervisor的web控制</li>
</ol>
<h1 id="supervisorctl">supervisorctl</h1>
<ol>
<li>supervisorctl status 查看进程状态</li>
<li>supervisorctl stop programname 停止某个进程</li>
<li>supervisorctl start all 启动所有进程</li>
</ol>
]]></content>
    
    
      <category term="supervisord" scheme="http://www.abbeychenxi.net/tags/supervisord/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scrapy中的Xpath]]></title>
    <link href="http://www.abbeychenxi.net/2014/12/16/Scrapy%E4%B8%AD%E7%9A%84Xpath/"/>
    <id>http://www.abbeychenxi.net/2014/12/16/Scrapy中的Xpath/</id>
    <published>2014-12-16T13:50:26.000Z</published>
    <updated>2014-12-16T14:06:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何在Scrapy的Xpath中使用正则？">如何在Scrapy的Xpath中使用正则？</h1>
<h2 id="需求">需求</h2>
<p>html中的部分a标签需要爬，很多脏数据可以通过a标签的 href 的指向的链接 去判别</p>
<h2 id="ok_进入正题">ok 进入正题</h2>
<h3 id="Scrapy_的EXSLT扩展">Scrapy 的EXSLT扩展</h3>
<h4 id="re">re</h4>
<p>例如在XPath的 starts-with() 或 contains() 无法满足需求时， test() 函数可以非常有用。</p>
<p>例如在列表中选择有”class”元素且结尾为一个数字的链接:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>doc = <span class="string">"""</span></div><div class="line"><span class="prompt">... </span>&lt;div&gt;</div><div class="line"><span class="prompt">... </span>    &lt;ul&gt;</div><div class="line"><span class="prompt">... </span>        &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</div><div class="line"><span class="prompt">... </span>        &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</div><div class="line"><span class="prompt">... </span>        &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;</div><div class="line"><span class="prompt">... </span>        &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</div><div class="line"><span class="prompt">... </span>        &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</div><div class="line"><span class="prompt">... </span>    &lt;/ul&gt;</div><div class="line"><span class="prompt">... </span>&lt;/div&gt;</div><div class="line"><span class="prompt">... </span>"""</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sel = Selector(text=doc, type=<span class="string">"html"</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sel.xpath(<span class="string">'//li//@href'</span>).extract()</div><div class="line">[<span class="string">u'link1.html'</span>, <span class="string">u'link2.html'</span>, <span class="string">u'link3.html'</span>, <span class="string">u'link4.html'</span>, <span class="string">u'link5.html'</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sel.xpath(<span class="string">'//li[re:test(@class, "item-\d$")]//@href'</span>).extract()</div><div class="line">[<span class="string">u'link1.html'</span>, <span class="string">u'link2.html'</span>, <span class="string">u'link4.html'</span>, <span class="string">u'link5.html'</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>

<p>既使用Xpath的原生操作，如何又使用Scrapy中的正则？<br>因为Scrapy中的Xpath是1.0版本 并不支持正则表达式<br>so， 上代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">description</span> = <span class="built_in">info</span>.xpath(<span class="string">'.//a[not[re:test(<span class="variable">@href</span>, "http://bbs.nju.edu.cn/\.+")]]/text() '</span>).extract()</div></pre></td></tr></table></figure>

<p>上面的xpath表达式，所有指向bbs.nju.edu.cn的子链接的a标签都不在爬取的范围内。</p>
<h4 id="集合操作">集合操作</h4>
<p>集合操作可以方便地用于在提取文字元素前从文档树中去除一些部分。</p>
<p>例如使用itemscopes组和对应的itemprops来提取微数据(来自<a href="http://schema.org/Product的样本内容" target="_blank" rel="external">http://schema.org/Product的样本内容</a>):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; doc = <span class="string">""</span><span class="string">"</span></div><div class="line">... &lt;div itemscope itemtype="http://schema.org/Product<span class="string">"&gt;</span></div><div class="line">...   &lt;span itemprop="name<span class="string">"&gt;Kenmore White 17"</span> Microwave&lt;/span&gt;</div><div class="line"><span class="keyword">...</span>   &lt;img src=<span class="string">"kenmore-microwave-17in.jpg"</span> alt=<span class="string">'Kenmore 17" Microwave'</span> /&gt;</div><div class="line"><span class="keyword">...</span>   &lt;div itemprop=<span class="string">"aggregateRating"</span></div><div class="line"><span class="keyword">...</span>     itemscope itemtype=<span class="string">"http://schema.org/AggregateRating"</span>&gt;</div><div class="line"><span class="keyword">...</span>    Rated &lt;span itemprop=<span class="string">"ratingValue"</span>&gt;<span class="number">3.5</span>&lt;/span&gt;/<span class="number">5</span></div><div class="line"><span class="keyword">...</span>    based on &lt;span itemprop=<span class="string">"reviewCount"</span>&gt;<span class="number">11</span>&lt;/span&gt; customer reviews</div><div class="line"><span class="keyword">...</span>   &lt;/div&gt;</div><div class="line"><span class="keyword">...</span></div><div class="line"><span class="keyword">...</span>   &lt;div itemprop=<span class="string">"offers"</span> itemscope itemtype=<span class="string">"http://schema.org/Offer"</span>&gt;</div><div class="line"><span class="keyword">...</span>     &lt;span itemprop=<span class="string">"price"</span>&gt;$<span class="number">55.00</span>&lt;/span&gt;</div><div class="line"><span class="keyword">...</span>     &lt;link itemprop=<span class="string">"availability"</span> href=<span class="string">"http://schema.org/InStock"</span> /&gt;In stock</div><div class="line"><span class="keyword">...</span>   &lt;/div&gt;</div><div class="line"><span class="keyword">...</span></div><div class="line"><span class="keyword">...</span>   Product description:</div><div class="line"><span class="keyword">...</span>   &lt;span itemprop=<span class="string">"description"</span>&gt;<span class="number">0.7</span> cubic feet countertop microwave.</div><div class="line"><span class="keyword">...</span>   Has six preset cooking categories and convenience features like</div><div class="line"><span class="keyword">...</span>   Add-A-Minute and Child Lock.&lt;/span&gt;</div><div class="line"><span class="keyword">...</span></div><div class="line"><span class="keyword">...</span>   Customer reviews:</div><div class="line"><span class="keyword">...</span></div><div class="line"><span class="keyword">...</span>   &lt;div itemprop=<span class="string">"review"</span> itemscope itemtype=<span class="string">"http://schema.org/Review"</span>&gt;</div><div class="line"><span class="keyword">...</span>     &lt;span itemprop=<span class="string">"name"</span>&gt;Not a happy camper&lt;/span&gt; -</div><div class="line"><span class="keyword">...</span>     by &lt;span itemprop=<span class="string">"author"</span>&gt;Ellie&lt;/span&gt;,</div><div class="line"><span class="keyword">...</span>     &lt;meta itemprop=<span class="string">"datePublished"</span> content=<span class="string">"2011-04-01"</span>&gt;April <span class="number">1</span>, <span class="number">2011</span></div><div class="line"><span class="keyword">...</span>     &lt;div itemprop=<span class="string">"reviewRating"</span> itemscope itemtype=<span class="string">"http://schema.org/Rating"</span>&gt;</div><div class="line"><span class="keyword">...</span>       &lt;meta itemprop=<span class="string">"worstRating"</span> content = <span class="string">"1"</span>&gt;</div><div class="line"><span class="keyword">...</span>       &lt;span itemprop=<span class="string">"ratingValue"</span>&gt;<span class="number">1</span>&lt;/span&gt;/</div><div class="line"><span class="keyword">...</span>       &lt;span itemprop=<span class="string">"bestRating"</span>&gt;<span class="number">5</span>&lt;/span&gt;stars</div><div class="line"><span class="keyword">...</span>     &lt;/div&gt;</div><div class="line"><span class="keyword">...</span>     &lt;span itemprop=<span class="string">"description"</span>&gt;The lamp burned out and now I have to replace</div><div class="line"><span class="keyword">...</span>     it. &lt;/span&gt;</div><div class="line"><span class="keyword">...</span>   &lt;/div&gt;</div><div class="line"><span class="keyword">...</span></div><div class="line"><span class="keyword">...</span>   &lt;div itemprop=<span class="string">"review"</span> itemscope itemtype=<span class="string">"http://schema.org/Review"</span>&gt;</div><div class="line"><span class="keyword">...</span>     &lt;span itemprop=<span class="string">"name"</span>&gt;Value purchase&lt;/span&gt; -</div><div class="line"><span class="keyword">...</span>     by &lt;span itemprop=<span class="string">"author"</span>&gt;Lucas&lt;/span&gt;,</div><div class="line"><span class="keyword">...</span>     &lt;meta itemprop=<span class="string">"datePublished"</span> content=<span class="string">"2011-03-25"</span>&gt;March <span class="number">25</span>, <span class="number">2011</span></div><div class="line"><span class="keyword">...</span>     &lt;div itemprop=<span class="string">"reviewRating"</span> itemscope itemtype=<span class="string">"http://schema.org/Rating"</span>&gt;</div><div class="line"><span class="keyword">...</span>       &lt;meta itemprop=<span class="string">"worstRating"</span> content = <span class="string">"1"</span>/&gt;</div><div class="line"><span class="keyword">...</span>       &lt;span itemprop=<span class="string">"ratingValue"</span>&gt;<span class="number">4</span>&lt;/span&gt;/</div><div class="line"><span class="keyword">...</span>       &lt;span itemprop=<span class="string">"bestRating"</span>&gt;<span class="number">5</span>&lt;/span&gt;stars</div><div class="line"><span class="keyword">...</span>     &lt;/div&gt;</div><div class="line"><span class="keyword">...</span>     &lt;span itemprop=<span class="string">"description"</span>&gt;Great microwave <span class="keyword">for</span> the price. It is small and</div><div class="line"><span class="keyword">...</span>     fits <span class="keyword">in</span> my apartment.&lt;/span&gt;</div><div class="line"><span class="keyword">...</span>   &lt;/div&gt;</div><div class="line"><span class="keyword">...</span>   <span class="keyword">...</span></div><div class="line"><span class="keyword">...</span> &lt;/div&gt;</div><div class="line"><span class="keyword">...</span> <span class="string">""</span><span class="string">"</span></div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; for scope in sel.xpath('//div[@itemscope]'):</div><div class="line">...     print "current scope:<span class="string">", scope.xpath('@itemtype').extract()</span></div><div class="line">...     props = scope.xpath('''</div><div class="line">...                 set:difference(./descendant::*/@itemprop,</div><div class="line">...                                .//*[@itemscope]/*/@itemprop)''')</div><div class="line">...     print "    properties:<span class="string">", props.extract()</span></div><div class="line">...     print</div><div class="line">...</div><div class="line"></div><div class="line">current scope: [u'http://schema.org/Product']</div><div class="line">    properties: [u'name', u'aggregateRating', u'offers', u'description', u'review', u'review']</div><div class="line"></div><div class="line">current scope: [u'http://schema.org/AggregateRating']</div><div class="line">    properties: [u'ratingValue', u'reviewCount']</div><div class="line"></div><div class="line">current scope: [u'http://schema.org/Offer']</div><div class="line">    properties: [u'price', u'availability']</div><div class="line"></div><div class="line">current scope: [u'http://schema.org/Review']</div><div class="line">    properties: [u'name', u'author', u'datePublished', u'reviewRating', u'description']</div><div class="line"></div><div class="line">current scope: [u'http://schema.org/Rating']</div><div class="line">    properties: [u'worstRating', u'ratingValue', u'bestRating']</div><div class="line"></div><div class="line">current scope: [u'http://schema.org/Review']</div><div class="line">    properties: [u'name', u'author', u'datePublished', u'reviewRating', u'description']</div><div class="line"></div><div class="line">current scope: [u'http://schema.org/Rating']</div><div class="line">    properties: [u'worstRating', u'ratingValue', u'bestRating']</div><div class="line"></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>

<p>在这里，我们首先在 itemscope 元素上迭代，对于其中的每一个元素，我们寻找所有的 itemprops 元素，并排除那些本身在另一个 itemscope 内的元素。</p>
]]></content>
    
    
      <category term="Scrapy" scheme="http://www.abbeychenxi.net/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust]]></title>
    <link href="http://www.abbeychenxi.net/2014/12/14/Rust/"/>
    <id>http://www.abbeychenxi.net/2014/12/14/Rust/</id>
    <published>2014-12-14T04:06:08.000Z</published>
    <updated>2014-12-14T04:08:07.000Z</updated>
    <content type="html"><![CDATA[<p>Rust 1.0 发布了。<br>这个看上去比Go的语法优美，简洁的静态编译型语言。</p>
<p>大致看了一下语法。和Swift很类似。</p>
<p>决定入坑Rust。</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS之协议和委托]]></title>
    <link href="http://www.abbeychenxi.net/2014/12/05/IOS%E4%B9%8B%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%A7%94%E6%89%98/"/>
    <id>http://www.abbeychenxi.net/2014/12/05/IOS之协议和委托/</id>
    <published>2014-12-04T16:06:53.000Z</published>
    <updated>2014-12-04T16:30:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="protocol">protocol</h1>
<blockquote>
<p>一个协议不实现任何它定义的方法。它的作用是：当一个对象遵从这个协议时，这个对象必须实现协议的所有方法。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AddItemViewControllerDelegate</span>: <span class="title">class</span> </span>{</div><div class="line">    <span class="func"><span class="keyword">func</span></span> addItemViewControllerDidCancel(controller: <span class="type">AddItemViewController</span>)</div><div class="line">    <span class="func"><span class="keyword">func</span></span> addItemViewController(controller: <span class="type">AddItemViewController</span>, didFinishAddingItem item: <span class="type">ChecklistItem</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了让ChecklistViewController遵从这个协议，它必须提供这两个方法的实现。从此你可以参考ChecklistViewController仅使用协议名称。<br>protocol 类似与 java 中的 interface</p>
<p>在AddItemViewController中，不需要再写:<br><code>var delegate: ChecklistViewController</code><br>而是写为:<br><code>var delegate: AddItemViewControllerDelegate</code></p>
<p>delegate这个变量对实现了这个协议的对象来说只是一个参考，引用。你可以通过delegate这个变量去发送信息给对象，而不需要直到这个对象到底是什么。</p>
<h1 id="简单的五部实现delegate">简单的五部实现delegate</h1>
<p>A是B的delegate，B将发送消息</p>
<ol>
<li>为B定义一个delegate协议</li>
<li>给B定义一个可选的delegate变量，这个变量必须是weak的</li>
<li>当事件发生的时候，让B向这个delegate发送消息</li>
<li>让A遵守这个协议。必须在类名后面加上协议的名字<code>class ChecklistViewController: AddItemViewControllerDelegate</code></li>
<li>告诉B，A现在已经是它的一个delegate</li>
</ol>
]]></content>
    
    
      <category term="IOS" scheme="http://www.abbeychenxi.net/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最长回文子串]]></title>
    <link href="http://www.abbeychenxi.net/2014/12/02/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://www.abbeychenxi.net/2014/12/02/最长回文子串/</id>
    <published>2014-12-01T16:46:34.000Z</published>
    <updated>2014-12-01T17:01:04.000Z</updated>
    <content type="html"><![CDATA[<p>转载自july</p>
<h1 id="最长回文子串">最长回文子串</h1>
<p>给定一个字符串，求它的最长回文子串的长度。</p>
<h2 id="分析与解法">分析与解法</h2>
<p>最容易想到的办法是枚举所有的子串，分别判断其是否为回文。这个思路初看起来是正确的，但却做了很多无用功，如果一个长的子串包含另一个短一些的子串，那么对子串的回文判断其实是不需要的。</p>
<p>那么如何高效的进行判断呢？我们想想，如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。</p>
<p>那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？答案是肯定的，参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">length = len(s)</div><div class="line">isPalinded = [[<span class="keyword">False</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(length)]<span class="keyword">for</span> n <span class="keyword">in</span> range(length)]</div><div class="line">maxOfLength = <span class="number">1</span></div><div class="line">start = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</div><div class="line">	isPalinded[i][i] = <span class="keyword">True</span></div><div class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</div><div class="line">			isPalinded[j][i] = (s[j] == s[i] <span class="keyword">and</span> (i - j &lt; <span class="number">2</span> <span class="keyword">or</span> isPalinded[j+<span class="number">1</span>][i-<span class="number">1</span>]))</div><div class="line">			<span class="keyword">if</span> isPalinded[j][i] <span class="keyword">and</span> maxOfLength &lt; (i - j + <span class="number">1</span>):</div><div class="line">				maxOfLength = i - j + <span class="number">1</span></div><div class="line">				start = j</div><div class="line"><span class="keyword">return</span> s[start : maxOfLength + <span class="number">1</span>]</div><div class="line"><span class="comment">#时间复杂度O(n^2)超过限制</span></div></pre></td></tr></table></figure>


<p> 代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。</p>
<h3 id="解法二、O(N)解法">解法二、O(N)解法</h3>
<p>在上文的解法一：枚举中心位置中，我们需要特别考虑字符串的长度是奇数还是偶数，所以导致我们在编写代码实现的时候要把奇数和偶数的情况分开编写，是否有一种方法，可以不用管长度是奇数还是偶数，而统一处理呢？比如是否能把所有的情况全部转换为奇数处理？</p>
<p>答案还是肯定的。这就是下面我们将要看到的Manacher算法，且这个算法求最长回文子串的时间复杂度是线性O(N)的。</p>
<p>首先通过在每个字符的两边都插入一个特殊的符号，将所有可能的奇数或偶数长度的回文子串都转换成了奇数长度。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。</p>
<p>此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#。</p>
<p>以字符串12212321为例，插入#和$这两个特殊符号，变成了 S[] = “$#1#2#2#1#2#3#2#1#”，然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。</p>
<p>比如S和P的对应关系：</p>
<p>S # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #<br>P 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1<br>可以看出，P[i]-1正好是原字符串中最长回文串的总长度，为5。</p>
<p>接下来怎么计算P[i]呢？Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论：</p>
<p>如果mx &gt; i，那么P[i] &gt;= Min(P[2 <em> id - i], mx - i)<br>下面，令j = 2</em>id - i，也就是说j是i关于id的对称点。</p>
<p>当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于i和j对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有P[i] = P[j]；<br><img src="https://camo.githubusercontent.com/6e347c94c2660435bde50fa5305135229c8d76cf/687474703a2f2f7777772e66656c69783032312e636f6d2f626c6f672f6174746163686d656e742f313331383437363238345f37393335346134372e706e67" alt=""></p>
<p>当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，再具体匹配。</p>
<p><img src="https://camo.githubusercontent.com/ff7edaf62027622be69d38aa3412b542328f8386/687474703a2f2f7777772e66656c69783032312e636f6d2f626c6f672f6174746163686d656e742f313331383437383131345f34333739666235632e706e67" alt=""></p>
<p>此外，对于 mx &lt;= i 的情况，因为无法对 P[i]做更多的假设，只能让P[i] = 1，然后再去匹配。</p>
<p>综上，关键代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">  <span class="comment"># @return a string</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processString</span><span class="params">(self, s)</span>:</span></div><div class="line">    s = <span class="string">" "</span>.join(s)</div><div class="line">    l = s.split(<span class="string">" "</span>)</div><div class="line">    l.insert(<span class="number">0</span>, <span class="string">'$'</span>)</div><div class="line">    s = <span class="string">'#'</span>.join(l)</div><div class="line">    s += <span class="string">'#^'</span></div><div class="line">    <span class="keyword">return</span> s</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">    s = self.processString(s)</div><div class="line">    <span class="comment"># print s</span></div><div class="line">    mx = <span class="number">0</span></div><div class="line">    id = <span class="number">0</span></div><div class="line">    p = [<span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, len(s))]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) - <span class="number">1</span>):</div><div class="line">      <span class="comment"># print i</span></div><div class="line">      p[i] = min(p[<span class="number">2</span> * id - i], mx - i) <span class="keyword">if</span> mx &gt; i <span class="keyword">else</span> <span class="number">1</span></div><div class="line">      <span class="keyword">while</span> s[i + p[i]] == s[i - p[i]]:</div><div class="line">        p[i] += <span class="number">1</span></div><div class="line">      <span class="keyword">if</span> i + p[i] &gt; mx:</div><div class="line">        mx = i + p[i]</div><div class="line">        id = i</div><div class="line">    maxLength = max(p)</div><div class="line">    index = p.index(maxLength)</div><div class="line">    start = index - maxLength + <span class="number">1</span></div><div class="line">    end = index + maxLength - <span class="number">1</span></div><div class="line">    s = s[start : end]</div><div class="line">    l = s.split(<span class="string">'#'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(l)</div></pre></td></tr></table></figure>


<p>此Manacher算法使用id、mx做配合，可以在每次循环中，直接对P[i]的快速赋值，从而在计算以i为中心的回文子串的过程中，不必每次都从1开始比较，减少了比较次数，最终使得求解最长回文子串的长度达到线性O(N)的时间复杂度。</p>
]]></content>
    
    
      <category term="LeetCode" scheme="http://www.abbeychenxi.net/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式系统]]></title>
    <link href="http://www.abbeychenxi.net/2014/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.abbeychenxi.net/2014/11/18/分布式系统/</id>
    <published>2014-11-18T14:43:01.000Z</published>
    <updated>2014-11-18T14:43:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="中间件在分布式系统中的地位和角色">中间件在分布式系统中的地位和角色</h2>
<p>为了使种类各异的计算机和网络都呈现为单个的系统，分布式系统常常通过一个“软件层”组织起来，该层在逻辑上位于由用户和应用程序组成的高层与由操作系统组成的低层之间，这样的分布式系统又称为中间件。中间件层延伸到了多台机器上，且为每个应用程序提供了相同的接口。它的重要的目的是提供一定程度的透明性，也就是一定程度上向应用程序隐藏数据处理的分布性。中间件集分布式操作系统与网络操作系统的优点于一身，既能够具有网络操作系统的可扩展性和开放性，又能够具有分布式操作系统的透明性和与之相关的易用性。</p>
<h2 id="分布式系统进程通信，rpc基本原理步骤">分布式系统进程通信，rpc基本原理步骤</h2>
<ol>
<li>客户过程以正常方式调用客户存根</li>
<li>客户存根生成一个消息，然后调用本地操作系统</li>
<li>客户端操作系统将消息发送给远程操作系统，并阻塞客户过程</li>
<li>远程操作系统将消息交给服务器存根</li>
<li>服务器存根将参数提取出来，然后调用服务器</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根</li>
<li>服务器存根将结果打成消息包，然后调用本地操作系统</li>
<li>服务器操作系统将消息发送回客户端操作系统</li>
<li>客户端操作系统将消息交给客户存根</li>
<li>客户存根将结果从消息中提取出来，返回给调用进程</li>
</ol>
<h2 id="移动agent特点">移动agent特点</h2>
<p>自主性；反应性；主动/面向目标；推理/学习/自适应能力；可移动性；社会性。</p>
<h2 id="命名服务(优缺点)">命名服务(优缺点)</h2>
<h2 id="移动实体定位">移动实体定位</h2>
<ol>
<li>广播和多播</li>
<li>转发指针</li>
<li>给实体指定一个起始位置</li>
<li>创建一颗搜索树</li>
</ol>
<h2 id="并发，petri网建模">并发，petri网建模</h2>
<h3 id="哲学家进餐">哲学家进餐</h3>
<p><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfhdhmzsgj218e0v4jv8.jpg" alt="哲学家进餐"></p>
<p>图解：</p>
<p>h-hunger   k-thinking   f –fork/chopstick   e-eating</p>
<ol>
<li>圆圈：hi,ki,ei,fi为库所<br>h：表示为哲学家饥饿状态库所 : k表示为哲学家思考状态的库所 e:表示为哲学家吃饭状态的库所 f:表示筷子处于备用状态的库所</li>
<li>黑色实心点为token。初始状态时：f0-f4中的是筷子，k0-k4中的是哲学家</li>
<li>方框为变迁<br>初始状态：筷子备用状态，处于f0-f4库所中。哲学家是思考状态，处于k0-k4中。</li>
</ol>
<p>以哲学家0为例</p>
<ul>
<li>T1 变迁1（感到饥饿）：哲学家在思考中感到饿了，从库所k0经过T1到达库所h0。哲学家从思考状态进入饥饿状态。</li>
<li>T2变迁2（获得筷子）：哲学家和筷子分别从h0，f4，f0库所经过T2迁移到库所e0。哲学家从饥饿状态进入吃饭状态。</li>
<li>T3变迁3（释放筷子）：吃完饭后，哲学家经过T3迁移到k0库所中，从吃饭状态转入思考状态。两只筷子经过T3，分别迁移到库所f0，f4，从使用状态进入备用状态。</li>
</ul>
<h3 id="生产者消费者">生产者消费者</h3>
<p><img src="http://ww4.sinaimg.cn/mw690/b34f7e8bgw1emfhj3gp7wj21fm0ladjn.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/mw690/b34f7e8bgw1emfhjevzcrj20te0isdhh.jpg" alt=""></p>
<h2 id="移动mogent通信失效（本地和异地）的解决方案">移动mogent通信失效（本地和异地）的解决方案</h2>
<ul>
<li>分析<ul>
<li>无论本地通信还是异地通信，其通信模型是一致的 </li>
<li>通信失效本质上都是因为在路由信件和实际信件传输过程中，目标agent发生了物理位置的变化，而这种变化是随机的，不可预计的。 </li>
</ul>
</li>
<li>结论<ul>
<li>通信失效现象并不是mogent系统特有的现象.它是一个因agent的移动而带来的可能会出现在任意一个移动agent系统中的普遍现象</li>
</ul>
</li>
<li>其它系统的处理<ul>
<li>Aglets：未见</li>
<li>Mole：<ul>
<li>将失效信件扔弃;</li>
<li>扔弃的同时回送错误信息</li>
<li>将失效信件就地保存,待被通信agent在回送时交付 </li>
</ul>
</li>
</ul>
</li>
<li>根本原因：<ul>
<li>移动：随机改变位置信息</li>
<li>通信：要求位置信息“暂时”不变</li>
<li>通信和移动所共享的“位置”信息未进行同步控制是造成通信失效的根本原因</li>
<li>从OS进程互斥考虑，接收者的“位置”在通信失效问题中具有决定性的意义，当通信和移动相矛盾时，该“位置”就成为了一个必须互斥使用的“资源” </li>
</ul>
</li>
<li>“位置”的互斥  ＝》  “状态”的互斥</li>
<li>在一个能够避免通信失效的移动agent系统中，必须且只要做到以下三条 ：<ul>
<li>准确纪录agent的状态信息 </li>
<li>只能向一个处于“静止态”的agent发送信件 </li>
<li>信件发送过程中必须限制接收者从“静止态”向“移动态”的状态转换 </li>
</ul>
</li>
</ul>
<h2 id="同步：逻辑时间算法，向量时间戳（将每个时间的向量时间戳标出）">同步：逻辑时间算法，向量时间戳（将每个时间的向量时间戳标出）</h2>
<p>Lamport算法：不能反应因果关系。</p>
<p>向量时钟 ：要求能计算出每个进程中的事件，标出向量的时间戳，不同事件之间的向量时间的大小关系，依赖关系与并发关系。</p>
<h3 id="逻辑时钟">逻辑时钟</h3>
<ul>
<li>为了同步逻辑时钟，Lamport定义了一个称作 “先发生” (happens-before) 的关系。表达式ab读作 “a在b之前发生”，意思是所有进程一致认为事件a先发生，然后事件b才发生。这种先发生关系有两种情况。 <ul>
<li>如果a和b是同一个进程中的两个事件，且a在之前发生，则ab为真。 </li>
<li>如果a是一个进程发送消息的事件，而b为另一个进程接收消息的事件，则ab也为真。消息不可能在发送之前被修改，也不能在发送的同时被接收，这是因为消息需要一定时间才能到达接收端。 </li>
<li>Lamport逻辑时间钟具有传递性和并发性；</li>
</ul>
</li>
<li>对这个算法稍作补充就可以满足全局时间的需要。即在每两个事件之间，时钟必须至少滴答一次。如果一个进程以相当快的速度发送或者接受两个消息，那么它的时钟必须在这之间至少滴答一次。 </li>
<li>在某些情况下还需要一个附加条件，即两个事件不会精确地同时发生。为了达到这个目标，我们可以将事件发生所在的进程号附加在时间的低位后，并用小数点分开。这样，如果进程1和进程2中的事件都发生在时刻40，那么前者记为40.1后者记为40.2。 </li>
<li>使用这种方法，我们现在有了一个为分布式系统中的所有事件分配时间的方法，它遵循下面的规则： <ul>
<li>若同一进程中a在b之前发生，则C(a)&lt;C(b)。 </li>
<li>若a和b分别代表发送一个消息和接收该消息的事件，则C(a)&lt;C(b)。 </li>
<li>对于所有不同的事件a和b，C(a) ≠ C(b)。</li>
</ul>
</li>
<li>这个算法为我们提供了一种对系统中所有事件进行完全排序的方法。许多其他的分布式算法都需要这种排序以避免混淆，所以文献中广泛引用此算法。 </li>
<li>使用Lamport时间戳后，只通过比较事件a和b各自的时间值C(a)和C(b)，无法说明它们之间的关系。换句话所，C(a)&lt;C(b)不能说明事件a就是在事件b之前发生。还需要另外一些信息。即 Lamport时间戳不能捕捉因果关系(causality)。</li>
</ul>
<h3 id="向量事件戳">向量事件戳</h3>
<p>为什么采用向量时间戳可以表示事件因果关系？</p>
<ul>
<li>因果关系可以通过向量时间戳来捕获。分配给事件a的向量时间戳VT(a)具有下列性质：如果对某一事件b，有VT(a)&lt;VT(b)，那么认为事件a在因果关系上处于事件b之前。向量时间戳的创建是通过让每个进程P维护一个向量V来完成的，该向量具有下面两个性质： <ul>
<li>Vi[i]是到目前为止进程Pi发生的事件的数量。 </li>
<li>如果Vi[j]=k，那么进程Pi知道进程Pj中已经发生了k个事件</li>
<li>第一个性质是通过在进程Pi中的新事件发生时递增Vi[i]来维护的。</li>
<li>第二个性质时通过在所发送的消息中携带向量来维护的。当进程Pi发送消息m时，它将自己的当前向量作为时间戳vt一起发送。 </li>
</ul>
</li>
<li>使用这种方式，接收者可以得知进程Pi中已经发生的事件数。</li>
<li>更重要的是，接收者可以得知进程Pi发送消息m之前其他进程已经发生了多少个事件。换句话说，消息m的时间戳vt告诉接收者其他进程中有多少事件发生在它之前，并且消息m可能在因果关系上依赖于这些事件。</li>
<li><p>当进程Pj接收到消息m时，它调整自己的向量，将每项Vj[k] 设置为max{Vj[k],vt[k]}。该向量现在反映了进程Pj必须接收的消息数，该消息数目至少是在发送消息m之前见到的消息。此后将Vj[i]项增1，这表示接收消息m的事件是来自于进程Pi的下一个事件。<br>只在不违背因果关系限制时，才能使用向量时间戳来传递消息。我们来再次考虑一下电子公告板的例子。当进程Pi张贴一篇文章时，它将该文章作为消息a广播出去，并且在该消息上附加一个时间戳vt(a)，其值等于V。当另一个进程Pj接收到a时，它将调整自己的向量，以使Vj[i]=vt(a)[i]。</p>
</li>
<li><p>现在假设进程Pj张贴了一个该文章的回复。回复是通过该进程广播一个消息r实现的，消息r携带值等于Vj的时间戳vt(r)。注意vt(r)[i]&gt; vt(a)[i]。假设通信是可靠的，包含文章的消息a和包含回复的消息r最终都到达了另一个进程Pk。因为我们没有对消息的顺序关系做出假设，所以消息r可能在消息a之前到达进程Pk。进程Pk接收到消息r时检查时间戳，并决定推迟提交消息r，直到因果关系上位于r之前的消息都接收到了才提交。消息r只有下列条件满足时才得到交付：<br>vt(r)[j]=vk[j]+1;<br>对于所有满足i¹j的i和j，vt(r)[i]&lt; Vk[i]<br>第一个条件说明r是进程Pk正在等待的下一条来自进程Pj的消息。<br>第二个条件说明当进程Pj发送消息r时，进程Pk只看到被进程Pj看到的消息。这意味着进程Pk已经看到了消息。</p>
</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfikdx9x2j20sq0wi0vu.jpg" alt=""></p>
<h2 id="一致性模型，要能写出以客户为中心的四个模型（条件描述）以数据为中心的三种类别（了解））">一致性模型，要能写出以客户为中心的四个模型（条件描述）以数据为中心的三种类别（了解））</h2>
<ol>
<li><p>每一个以客户为中心的一致性模型是单调读的一致性模型。如果数据存储满足以下条件，那么称该数据存储提供单调读一致性(monotonic-read consistency)： </p>
<ul>
<li><p>如果一个进程读取数据x的值，那么该进程对执行任何后续读操作将总是得到第一次读取的那个值或更新的值。 </p>
<p>也就是说，单调读一致性保证，如果一个进程已经在t时刻看到x的值，那么以后他不再会看到较老的版本的x的值。 </p>
</li>
</ul>
</li>
<li><p>在很多情况下，写操作以正确的顺序传播到数据存储的所有拷贝是非常重要的。这种性质被描述为单调写一致性。单调写一致性(monotonic-write consistency)的数据存储应该满足以下条件： </p>
<ul>
<li>一个进程对数据项x执行的写操作必须在该进程对x执行任何后续写操作之前完成。 </li>
</ul>
</li>
<li><p>下面介绍一种与单调写一致性有密切关系的以客户为中心的一致性模型。如果数据存储满足以下条件，那么称该数据存储提供写后读一致性(read-your-writes consistency)。 </p>
<ul>
<li><p>一个进程对数据项x执行一次写操作的结果总是会被该进程对x执行的后续读操作看见。 </p>
<p>也就是说，一个写操作总是在同一进程执行的后续读操作之前完成，而不管这个后续的读操作发生在什么位置。</p>
</li>
</ul>
</li>
<li><p>最后一种以客户为中心的一致性模型是这样的模型，即更新是作为前一个读操作的结果传播的。如果数据存储满足以下条件，那么称该数据存储提供读后写一致性(writes-follow-reads consistency)。 </p>
<ul>
<li><p>同一个进程对数据项x执行的读操作之后的写操作，保证发生在与x读取值相同或比之更新的值上。</p>
<p>也就是说，进程对数据项上x所执行的任何后续的写操作都会在x的拷贝上执行，而该拷贝是用该进程最近读取的值更新的。</p>
</li>
</ul>
</li>
</ol>
<h2 id="代码迁移（基础、分类）">代码迁移（基础、分类）</h2>
<p>分布式系统中的代码迁移是以进程迁移(process migration)的形式进行的，在这种形式下整个进程被从一台机器搬到另一台机器上去。其基本的思想是：如果把进程由负载较重的机器上转移到负载较轻的机器上去，就可以提升系统的整体性能。（迁移的是计算程序本身，而非数据）</p>
<h3 id="分类">分类</h3>
<ul>
<li>弱可迁移性：在这种模型中，可以只传输代码段以及某些初始化数据。弱可移动性的典型特征是，传输过来的程序总是以初始状态重新开始执行的。</li>
<li>强可移动性(strong mobility)：它还可以迁移执行段。强可移动性的典型特征是，可以先停止运行中的进程，然后将它搬到另一台机器上去，再从刚才中断的位置继续执行。 </li>
</ul>
<p>分类（主动方）：</p>
<ul>
<li>发送者启动(sender-initiated)迁移：在这种模型中，代码当前驻留在哪台机器上或者正在哪台机器上执行，就由该机器来启动迁移。一般来说，在向计算服务器上载程序时进行的就是发送者启动的迁移。</li>
<li>接收者启动(receiver-initiated)迁移：代码迁移的主动权掌握在目标机器手中。Java小程序是这种迁移的一个例子。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfinpb34nj21au0p2dj7.jpg" alt=""></p>
<h2 id="事务提交：2pc\3pc">事务提交：2pc\3pc</h2>
<ol>
<li><p>两阶段提交协议(2PC)：考虑一个分布式事务中有很多进程作为参与者，每个进程都运行在不同的机器上。假定没有故障发生，协议就由以下两个阶段组成，每个阶段又由两步组成。</p>
<ul>
<li>协调者向所有的参与者发送一个Vote_Request消息。 </li>
<li>当参与者接收到Vote_Request消息时，就向协调者返回一个Vote_Commit消息通知协调者它已经准备好本地提交事务中属于它的部分，否则就返回一个Vote_Abort消息。 </li>
<li>协调者收集来自参与者的所有选票。如果所有的参与者都表决要提交事务，那么协调者就进行提交。在这种情况下它向所有的参与者发送一个Global_Commit消息。但是，如果有一个参与者表决要取消事务，那么协调者就决定取消事务并多播一个Global_Abort消息。 </li>
<li><p>每个提交表决的参与者都等待协调者的最后反应。如果参与者接收到一个Global_Commit消息，那么它就在本地提交事务，否则接收到一个Global_Abort消息时，就在本地取消事务。<br><img src="http://ww4.sinaimg.cn/mw690/b34f7e8bjw1emfibctv28j21bi0cudi7.jpg" alt=""></p>
<ul>
<li>The finite state machine for the coordinator in 2PC.（协调者）</li>
<li>The finite state machine for a participant.（参与者）</li>
</ul>
<p>两阶段提交的一个问题在于当协调者崩溃时，参与者不能做出最后的决定。因此参与者可能在协调者恢复之前保持阻塞。三阶段提交协议(3PC)，避免了在出现故障停机时的阻塞过程。</p>
</li>
</ul>
</li>
<li><p>三阶段提交（3PC）</p>
<p> 3PC的本质在于协调者和每个参与者都满足以下两个条件： </p>
<ul>
<li>没有一个可以直接转换到Commit或者Abort状态的单独状态。 </li>
<li><p>没有一个这样的状态：它不能做出最后决定，而且可以从它直接转换到Commit状态。  </p>
<p>三阶段提交协议(3PC)的基本原理为：在2PC的参与者投票和协调者决策之间增加了“预提交”阶段。协调者在接收到所有参与者的提交票后发送一个全局预提交命令，当参与者接收到全局预提交命令之后，它就得知其他的参与者都投了提交票，从而确定自己在稍后肯定会执行提交操作，除非它失败了。每个参与者都对全局预提交发出确认消息，协调者一旦接收到所有参与者的确认消息就再发出“全局性提交”。3PC协议在站点失败，甚至是所有的站点都失败的情况下也不会带来阻塞。</p>
<p>它们各自的状态机如图所示。（a 协调者，b 参与者）<br><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfidmwjbnj21d40hwwhr.jpg" alt=""></p>
</li>
</ul>
</li>
</ol>
<ul>
<li>二者比较：</li>
</ul>
<p>与2PC相比，3PC的主要不同点在于以下情况：崩溃的参与者可能恢复到了Commit状态而所有参与者还处于Ready状态。在这种情况下，其余的可能操作进程不能做出最后的决定，不得不在崩溃的进程恢复之前阻塞。在3PC中，只要有可操作的进程处于Ready状态，就没有崩溃的进程可以恢复到Init、Abort或Precommit之外的状态。因此存活进程总是可以做出的最后决定。 </p>
<h2 id="复制和一致性（四个经典模型（不带同步变量的））">复制和一致性（四个经典模型（不带同步变量的））</h2>
<ol>
<li><p>严格一致性</p>
<p> 条件定义：对于数据项x的任何读操作将返回最近一次对x进行的写操作的结果所对应的值。 </p>
<p> 严格一致性中存在的问题是它依赖于绝对的全局时间(注意由于技术的限制,我们需要处理同一时间间隔内所发生的多个操作)</p>
<p> <img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfhxjvyg6j21d409qwex.jpg" alt=""><br> (a)严格的一致性存储; (b) 非严格的一致性存储 </p>
<p> 总之，当数据存储是严格一致的时候，对于所有的进程来说，所有写<br> 操作是瞬间可见的，系统维持着一个绝对的全局时间顺序。(如果一<br> 个数据项被改变了，那么无论数据项改变之后多久执行读操作，无论<br> 哪些进程执行读操作，无论这些进程的位置如何，所有在该数据项上<br> 执行的后续读操作都将得到新数值。同样，如果执行了读操作，那么<br> 无论多快地执行下一个写操作，该读操作都将得到当前的值。 )</p>
</li>
</ol>
<ol>
<li><p>顺序一致性</p>
<p> 条件定义: </p>
<p> 任何执行结果都是相同的，就好像所有进程对数据存储的读、写操作    时按照某种序列顺序执行的，并且每个进程的操作按照程序所制定的    顺序出现在这个序列中。 </p>
<p> <img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfi1uz27qj21aa09iab4.jpg" alt=""><br> (a) 顺序一致的数据存储； (b)非顺序一致的数据存储 </p>
</li>
<li><p>线性一致性</p>
<p> 条件定义：当数据存储上的每个操作都具有时间戳并满足以下条件时，称这个数据存储是可线性化的。任何执行结果都是相同的，就好像所有进程对数据存储的读、写操作是按某种顺序执行的，并且每个进程的操作按照顺序所执行的顺序出现在这个顺序中。另外，如果tsop1(x)&lt;tsop2(y)，那么在这个顺序中，操作OP1(x)出现在操作OP2之前。 （注意，可线性化的数据存储也是顺序一致的。它们的区别在于：线性化是根据一系列同步时钟确定序列顺序的。在实际应用中，线性化主要用于开发算法的形式验证。关于根据时间戳维护顺序的附加限制使得线性化的实现比顺序一致性的实现开销更大。Tsop(x)—-时间戳）。</p>
</li>
<li><p>因果一致性</p>
<p> 因果关系理解：考虑一个存储器的实例。假设进程P1对变量x执行了写操作。然后进程P2先读取x，然后对y执行写操作。这里，对x的读操作和对y的写操作具有潜在的因果关系，因为y的计算可能依赖于P2所读取的x值。没有因果关系的操作被称为并发的。</p>
<p> 条件定义：所有进程必须以相同的顺序看到具有潜在因果关系的写操作。不同机器上的进程可以以不同的顺序被看到并发的写操作。<br>实现因果一致性要求跟踪哪些进程看到了哪些写操作。这意味着必须构建和维护一张记录哪些操作依赖于哪些操作的依赖关系图。一种实现方法是使用上一章所讨论的向量时间戳。</p>
</li>
</ol>
<h2 id="分布式系统算法（选举算法（欺负算法）、互斥算法（集中式带协调者的、分布式不带协调者的、recut、令牌环（不一定考）））">分布式系统算法（选举算法（欺负算法）、互斥算法（集中式带协调者的、分布式不带协调者的、recut、令牌环（不一定考）））</h2>
<h2 id="选举算法">选举算法</h2>
<h3 id="欺负算法">欺负算法</h3>
<p>1.1 当任何一个进程发现协调者不再响应请求时，它就发起一个选举。进程P按如下过程主持一次选举： </p>
<ul>
<li>1.1.1 P向所有编号比它大的进程发送一个election消息； </li>
<li>1.1.2 如果无人响应，P获胜成为协调者； </li>
<li>1.1.3 如果有编号比它大的进程响应，则响应者接管选举工作。P的工作完成。</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/mw690/b34f7e8bgw1emfhom07xqj21ci0fqwgr.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/mw690/b34f7e8bgw1emfhomlpx8j21ba0fgdhe.jpg" alt=""></p>
<ul>
<li>(a)  进程4主持一个选举；</li>
<li>(b) 进程5和6进行响应，告诉进程4停止选举；</li>
<li>(c) 进程5和6此时各自主持一个选举；</li>
<li>(d) 进程6通知进程5停止选举；</li>
<li>(e) 进程6获胜，并通知每个进程。</li>
</ul>
<h2 id="互斥算法">互斥算法</h2>
<h3 id="集中式算法">集中式算法</h3>
<p>只有一个协调者，无论何时一个进程要进入临界区，它都要向协调者发送一个请求消息，说明它想要进入哪个临界区并请求允许。如果当前没有其他进程在该临界区内，协调者就发送允许进入的应答消息。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/b34f7e8bgw1emfht04vfvj21900e0q4l.jpg" alt=""></p>
<ul>
<li>(a) 进程1请求协调者允许它进入一个临界区。请求得到了批准； </li>
<li>(b) 进程2也请求进入同一个临界区。协调者不应答；进程2进入等待队列</li>
<li>(c) 进程1在退出临界区时通知协调者，协调者然后做出应答。协调者再通知等待队列中的排在最前面的进程2进入临界区</li>
<li>优点：没有进程会处于永远等待状态(不会出现饿死的情况)；易于实现，每使用一次临界区只需3条消息(请求、允许和释放)；不仅能用于管理临界区，也可以用于更一般的资源分配。 </li>
<li>缺点：协调者是一个单个故障点，所以如果它崩溃了，整个系统就可能瘫痪。在一般情况下，如果进程在发出请求之后被阻塞，那么请求者就不能区分“拒绝进入”和协调者已经崩溃这两种情况，因为上述两种情况都没有消息返回。此外，在规模较大的系统中，单个协调者会成为性能的瓶颈。</li>
</ul>
<h3 id="分布式算法">分布式算法</h3>
<p>该算法的工作过程如下：当一个进程想进入一个临界区时，它构造一个消息，其中包含它要进入的临界区的名字、它的进程号和当前时间。然后它将消息发送给所有其他的进程，理论上讲也包括它自己。<br>当一个进程接收到来自另一个进程的请求消息时，它根据自己与消息中的临界区相关的状态来决定它要采取的动作。可以分为三种情况： </p>
<ul>
<li>2.1 若接收者不再临界区也不想进入临界区，它就向发送者发送一个OK消息。 </li>
<li>2.2 若接收者已经在临界区，它不进行应答，而是将该请求放入队列中。 </li>
<li>2.3 如果接收者想进入临界区但尚未进入时，它将对收到的消息的时间戳和包含在它发送给其余进程的消息中的时间戳进行比较。时间戳最早的那个进程获胜。如果收到的消息的时间戳比较早，那么接收者向发送者发回一个OK消息。如果它自己的消息的时间戳比较早，那么接收者将接收到的请求放入队列中，并且不发送任何消息。</li>
</ul>
<p>在发送了请求进入临界区的请求消息后，进程进行等待，直到其他所有进程都发回允许进入消息为止。一旦得到所有进程的允许，它就可以进入临界区了。当它退出临界区时，它向其他队列中的所有进程发送OK消息，并将它们从队列中删除。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/b34f7e8bgw1emfhuu9pp4j21bm0f8q4d.jpg" alt=""></p>
<ul>
<li>(a) 两个进程同时希望进入同一个临界区； </li>
<li>(b) 进程0具有最早的时间戳，所以它获胜； </li>
<li>(c) 当进程0退出临界区时，它发送一个OK消息，所以进程2现在可以进入临界区 <ul>
<li>优点：不会发生死锁或者饿死现象；最大的优点是不存在单个故障点。</li>
<li>缺点：单个故障点被n个故障点所取代；要求更多网络通信的算法；要么必须使用组通信原语，要么每个进程都必须自己维护组成员的清单，清单中包括进入组的进程、离开组的进程以及崩溃的进程。</li>
</ul>
</li>
</ul>
<h3 id="令牌环">令牌环</h3>
<p>当环初始化时，进程0得到一个令牌token。该令牌绕着环运行，用点对点发送消息的方式把它从进程k传递到进程k+1(以环大小为模)。进程从它邻近的进程得到令牌后，检查自己是否要进入临界区。如果自己要进入临界区，那么它就进入临界区，做它要做的工作，然后离开临界区。在该进程退出临界区后，它沿着环继续传递令牌。不允许使用同一个令牌进入另一个临界区。如果一个进程得到了邻近进程传来的令牌，但是它并不想进入临界区，那么它只是将令牌沿环往下传递。</p>
<ul>
<li>优点：不会发生饿死现象，那么最差的情况是等待其他所有进程都进入这个临界区然后再从中退出后它再进去。</li>
<li>缺点：如果令牌丢失了，那么它必须重新生成令牌，检测令牌丢失是很困难的；如果有进程崩溃，该算法也会出现麻烦，但是恢复起来比其他算法容易。</li>
</ul>
]]></content>
    
    
      <category term="分布式" scheme="http://www.abbeychenxi.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="NJUStudying" scheme="http://www.abbeychenxi.net/categories/NJUStudying/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关联规则]]></title>
    <link href="http://www.abbeychenxi.net/2014/11/12/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/"/>
    <id>http://www.abbeychenxi.net/2014/11/12/关联规则/</id>
    <published>2014-11-12T01:48:27.000Z</published>
    <updated>2014-11-12T01:49:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="关联规则">关联规则</h2>
<h1 id="关联规则挖掘">关联规则挖掘</h1>
<p>$ support(A =&gt; B) = P(A U B) $<br>$ confidence(A =&gt; B) = P(AUB)/P(A) $</p>
<ol>
<li>找出频繁项集</li>
<li>由频繁项集产生强关联规则</li>
</ol>
<h1 id="由事务数据库挖掘单维布尔关联规则">由事务数据库挖掘单维布尔关联规则</h1>
<h2 id="Apriori算法:_使用候选项集找频繁项集">Apriori算法: 使用候选项集找频繁项集</h2>
<ol>
<li>连接</li>
<li>剪枝</li>
</ol>
<h2 id="由频繁项集产生关联规则">由频繁项集产生关联规则</h2>
<p>$ confidence(A =&gt; B) = P(A|B) = supportcount(A U B)\div supportcount(A) $</p>
<h2 id="提高Apriori有效性">提高Apriori有效性</h2>
<ol>
<li>基于散列的技术</li>
<li>事务压缩</li>
<li>划分</li>
<li>选样</li>
<li>动态项集计数</li>
</ol>
<p><em>FP-树</em></p>
<h3 id="冰山查询">冰山查询</h3>
<h1 id="多层关联规则">多层关联规则</h1>
<h2 id="挖掘量化关联规则">挖掘量化关联规则</h2>
<ul>
<li>分箱: 等宽分箱 等深分箱 基于同质分箱</li>
<li>找频繁谓词集</li>
<li>关联规则聚类</li>
</ul>
<p>A和B相关性: $ P(A U B)\div (P(A) * P(B)) $</p>
]]></content>
    
    
      <category term="data mining" scheme="http://www.abbeychenxi.net/tags/data-mining/"/>
    
      <category term="NJUStudying" scheme="http://www.abbeychenxi.net/categories/NJUStudying/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[bcy抓站小结]]></title>
    <link href="http://www.abbeychenxi.net/2014/10/31/bcy%E6%8A%93%E7%AB%99%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.abbeychenxi.net/2014/10/31/bcy抓站小结/</id>
    <published>2014-10-31T10:30:22.000Z</published>
    <updated>2014-10-31T10:38:39.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>目标: 抓取bcy.net/party/all所有的漫展信息</li>
<li>分析发现 bcy.net 通过js，ajax请求 获取下周等标签下的漫展信息</li>
</ol>
<h2 id="解决方案">解决方案</h2>
<ol>
<li>尝试通过Scrapyjs来模拟js交互。但是没有弄得middleware等等问题</li>
<li>尝试使用webdriver；但是速度太慢，严重影响效率</li>
<li>研究bcy的network标签，发现下周等标签会有一个ajax的post请求</li>
</ol>
<h2 id="最终解决方法">最终解决方法</h2>
<ul>
<li>研究ajax的post请求，发现网页指向<a href="http://bcy.net/party/expo/almexpoindex" target="_blank" rel="external">http://bcy.net/party/expo/almexpoindex</a></li>
<li>打开 <a href="http://bcy.net/party/expo/almexpoindex" target="_blank" rel="external">http://bcy.net/party/expo/almexpoindex</a> 查看network标签，发现有一个get请求</li>
<li>回到之前页面，找到ajax请求下面的formdata数据，利用formdata数据构建新的url，模拟post请求</li>
<li>查看network标签，成功收到返回的网页漫展信息的数据</li>
</ul>
<h1 id="大功告成！">大功告成！</h1>
]]></content>
    
    
      <category term="Scrapy" scheme="http://www.abbeychenxi.net/tags/Scrapy/"/>
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="cosjy" scheme="http://www.abbeychenxi.net/categories/cosjy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[manzhan.com的爬虫抓站小结]]></title>
    <link href="http://www.abbeychenxi.net/2014/10/23/manzhan-com%E7%9A%84%E7%88%AC%E8%99%AB%E6%8A%93%E7%AB%99%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.abbeychenxi.net/2014/10/23/manzhan-com的爬虫抓站小结/</id>
    <published>2014-10-22T17:13:55.000Z</published>
    <updated>2014-10-25T19:05:35.000Z</updated>
    <content type="html"><![CDATA[<p>目标网站: www.manzhan.com<br>使用框架: Scrapy</p>
<h1 id="新建项目">新建项目</h1>
<p><code>scrapy startproject manzhan</code></p>
<p>各文件的作用:</p>
<ul>
<li>scrapy.cfg: 项目的配置文件</li>
<li>manzhan/: 项目的Python模块</li>
<li>manzhan/items.py: 项目的items文件</li>
<li>manzhan/pipelines.py: 项目的pipelines文件</li>
<li>manzhan/settings.py: 项目的设置文件</li>
<li>manzhan/spiders/: 存储爬虫的目录</li>
</ul>
<h1 id="明确目标">明确目标</h1>
<p>在Scrapy中，items是用来加载抓取内容的容器。<br>需要抓取的内容：</p>
<ul>
<li>title</li>
<li>date</li>
<li>location</li>
<li>site</li>
<li>theme</li>
<li>type</li>
<li>link</li>
</ul>
<p>创建item类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="title">from</span> scrapy.item <span class="import"><span class="keyword">import</span> Item, Field</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> manzhanItem<span class="container">(<span class="type">Item</span>)</span>:</div><div class="line">	title = <span class="type">Field</span><span class="container">()</span></div><div class="line">	date = <span class="type">Field</span><span class="container">()</span></div><div class="line">	location = <span class="type">Field</span><span class="container">()</span></div><div class="line">	site = <span class="type">Field</span><span class="container">()</span></div><div class="line">	theme = <span class="type">Field</span><span class="container">()</span></div><div class="line">	type = <span class="type">Field</span><span class="container">()</span></div><div class="line">	link = <span class="type">Field</span><span class="container">()</span></div></pre></td></tr></table></figure>

<h1 id="制作爬虫">制作爬虫</h1>
<p>制作爬虫分为两步: 先爬再取</p>
<h2 id="爬">爬</h2>
<p>Spider是用户自己编写的类，用来从一个域内抓取信息。<br>他们定义了用于下载的URL列表、跟踪链接的方案、解析网页内容的方式，以此来提取items。<br>要建立一个Spider，你必须用scrapy.spider.BaseSpider创建一个子类，并确定三个强制的属性:</p>
<ul>
<li>name: 爬虫的识别名称，必须唯一</li>
<li>start_urls: 爬虫的URL列表。爬虫从这里开始抓取数据。第一次的数据会从这些urls开始。其他子URL将会从这些起始URL中继承性生成</li>
<li>parse(): 解析方法，调用的时候传入从每一个URL传回的Response对象作为唯一参数，负责解析并匹配抓取的数据，跟踪更多的URL。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scrapy.spider <span class="keyword">import</span> Spider</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManzhanSpider</span><span class="params">(Spider)</span>:</span></div><div class="line">	name = <span class="string">"manzhan"</span></div><div class="line">	allowed_domains = [<span class="string">"manzhan.com"</span>]</div><div class="line">	start_urls = [</div><div class="line">		<span class="string">"http://www.manzhan.com"</span></div><div class="line">	]</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">		filename = response.url</div><div class="line">		open(filename, <span class="string">'wb'</span>).write(response.body)</div></pre></td></tr></table></figure>

<p>allow_domains是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页。<br>测试 scrapy crawl manzhan</p>
<h2 id="取">取</h2>
<p>在基础的爬虫里，这一步可以用正则式来抓。<br>在Scrapy里，使用一种叫做Xpath selectors的机制，它基于Xpath表达式。<br>在Scrapy里面， Selectors有四种基础的方法:</p>
<ul>
<li>xpath(): 返回一系列的selectors，每一个select表示一个xpath参数表达式选择的节点</li>
<li>css(): 返回一系列的selectors，每一个select表示一个css参数表达式选择的节点</li>
<li>extract(): 返回一个unicode字符串，为选中的数据</li>
<li>re(): 返回一串一个unicode字符串，为使用正则表达式抓取出来的内容</li>
</ul>
<p>具体的xpath表达式</p>
<ul>
<li>nodename  选取此节点的所有子节点</li>
<li>/   从根节点选取</li>
<li>//  从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</li>
<li>.   选取当前节点</li>
<li>..  选取当前节点的父节点</li>
<li>@   选取属性</li>
<li>count 当前节点包含其他节点</li>
<li>[1] 当前节点在文件中的位置</li>
</ul>
<p>parse函数更改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">	sel = Selector(response)</div><div class="line">	infos = sel.xpath(<span class="string">'//tr[count(td)=6]'</span>)</div><div class="line">	<span class="keyword">for</span> info <span class="keyword">in</span> infos.xpath(<span class="string">'.//td'</span>):</div><div class="line">		<span class="keyword">pass</span></div></pre></td></tr></table></figure>

<p><a href="https://github.com/Abbeychenxi/cosjy" target="_blank" rel="external">代码git地址</a></p>
<h1 id="存储内容">存储内容</h1>
<p>保存信息的最简单的方法是通过Feed exports，主要有四种：JSON，JSON lines，CSV，XML。<br>我们将结果用最常用的JSON导出</p>
<p><code>scrapy crawl manzhan -o items.json -t json</code></p>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
      <category term="Scrapy" scheme="http://www.abbeychenxi.net/tags/Scrapy/"/>
    
      <category term="cosjy" scheme="http://www.abbeychenxi.net/categories/cosjy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[node异步开发难题]]></title>
    <link href="http://www.abbeychenxi.net/2014/10/07/node%E5%BC%82%E6%AD%A5%E5%BC%80%E5%8F%91%E9%9A%BE%E9%A2%98/"/>
    <id>http://www.abbeychenxi.net/2014/10/07/node异步开发难题/</id>
    <published>2014-10-07T14:36:10.000Z</published>
    <updated>2014-10-25T14:34:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="作用域导致bug">作用域导致bug</h2>
<p>javascript闭包可以“冻结”变量的值，调用的时候将变量值封装到匿名函数里。这样可以马上执行这个匿名函数，把当前的color的值传给它。而color变成了匿名函数的参数，成为匿名函数的本地变量，所以外部的color变化时，不会影响到本地的color值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span><span class="params">(callback)</span> </span>{</div><div class="line">	setTimeout(<span class="keyword">callback</span>, <span class="number">200</span>);</div><div class="line">}</div><div class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(color)</span> </span>{</div><div class="line">	asyncFunction(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">		console.log(<span class="string">'xxxx'</span>);</div><div class="line">	}) </div><div class="line">})(color);</div><div class="line"></div><div class="line">color = <span class="string">'green'</span>;</div></pre></td></tr></table></figure>

<h2 id="Nimble实现串行化控制">Nimble实现串行化控制</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flow = <span class="built_in">require</span>(<span class="string">'nimble'</span>);</div><div class="line"></div><div class="line">flow.series([</div><div class="line">	<span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>{</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">			callback();</div><div class="line">		}, <span class="number">1000</span>)</div><div class="line">	},</div><div class="line">	<span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>{</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">			callback();</div><div class="line">		}, <span class="number">500</span>)</div><div class="line">	}	</div><div class="line">]);</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="node.js" scheme="http://www.abbeychenxi.net/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python在函数中接收元组和列表]]></title>
    <link href="http://www.abbeychenxi.net/2014/09/29/Python%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8E%A5%E6%94%B6%E5%85%83%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8/"/>
    <id>http://www.abbeychenxi.net/2014/09/29/Python在函数中接收元组和列表/</id>
    <published>2014-09-29T13:02:11.000Z</published>
    <updated>2014-10-25T18:30:53.000Z</updated>
    <content type="html"><![CDATA[<p>当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，分别使用<em>和*</em>前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">powersum</span><span class="params">(power, *args)</span>:</span></div><div class="line">	total = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> args:</div><div class="line">		total += pow(i. power)</div><div class="line">	<span class="keyword">return</span> total</div><div class="line"></div><div class="line">power(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure>

<p>由于在args变量前有<em>前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是*</em>前缀，多余的参数则会被认为是一个字典的键/值对。</p>
<h2 id="lambda形式">lambda形式</h2>
<p>用来创建新的函数对象，并在运行时返回它们。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_repeater</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span> s: s*n</div><div class="line">	</div><div class="line">twice = make_repeater(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> twice(<span class="string">'word'</span>)</div><div class="line"><span class="keyword">print</span> twice(<span class="number">5</span>)</div></pre></td></tr></table></figure>

<h2 id="exec和eval语句">exec和eval语句</h2>
<p>exec语句用来执行储存在字符串或文件中的Python语句。<br><code>exec &#39;print &quot;Hello World&quot;&#39;</code></p>
<p>eval语句用来计算存储在字符串中的有效Python表达式。<br><code>eval(&#39;2*3&#39;)</code></p>
<h2 id="repr函数">repr函数</h2>
<p>repr函数用来取得对象的规范字符串表。<br><code>eval (repr(object)) == object</code></p>
]]></content>
    
    
      <category term="python" scheme="http://www.abbeychenxi.net/tags/python/"/>
    
  </entry>
  
</feed>
